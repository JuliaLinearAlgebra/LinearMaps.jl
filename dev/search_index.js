var documenterSearchIndex = {"docs":
[{"location":"history/#Version-history","page":"Version history","title":"Version history","text":"","category":"section"},{"location":"history/#What's-new-in-v3.10","page":"Version history","title":"What's new in v3.10","text":"","category":"section"},{"location":"history/","page":"Version history","title":"Version history","text":"A new MulStyle trait called TwoArg has been added. It should be used for LinearMaps that do not admit a mutating multiplication à la (3-arg or 5-arg) mul!, but only out-of-place multiplication à la A * x. Products (aka CompositeMaps) and sums (aka LinearCombinations) of TwoArg-LinearMaps now have memory-optimized multiplication kernels. For instance, A*B*C*x for three TwoArg-LinearMaps A, B and C now allocates only y = C*x, z = B*y and the result of A*z.\nThe construction of function-based LinearMaps, typed FunctionMap, has been rearranged. Additionally to the convenience constructor LinearMap{T=Float64}(f, [fc,] M, N=M; kwargs...), the newly exported constructor FunctionMap{T,iip}(f, [fc], M, N; kwargs...) is readily available. Here, iip is either true or false, and encodes whether f (and fc if present) are mutating functions. In the convenience constructor, this is determined via the Bool keyword argument ismutating and may not be fully inferred.","category":"page"},{"location":"history/#What's-new-in-v3.9","page":"Version history","title":"What's new in v3.9","text":"","category":"section"},{"location":"history/","page":"Version history","title":"Version history","text":"The application of LinearMaps to vectors operation, i.e., (A,x) -> A*x = A(x), is now differentiable w.r.t. to the input x for integration with machine learning frameworks such as Flux.jl. The reverse differentiation rule makes A::LinearMap usable as a static, i.e., non-trainable, layer in a network, and requires the adjoint A' of A to be defined.\nNew map types called KhatriRaoMap and FaceSplittingMap are introduced. These correspond to lazy representations of the column-wise Kronecker product and the row-wise Kronecker product (or \"transposed Khatri-Rao product\"), respectively. They can be constructed from two matrices A and B via khatrirao(A, B) and facesplitting(A, B), respectively. The first is particularly efficient as it makes use of the vec-trick for Kronecker products and computes y = khatrirao(A, B) * x for a vector x as y = vec(B * Diagonal(x) * transpose(A)). As such, the Khatri-Rao product can actually be built for general LinearMaps, including function-based types. Even for moderate sizes of 5 or more columns, this map-vector product is faster than first creating the explicit Khatri-Rao product in memory and then multiplying with the vector; not to mention the memory savings. Unfortunately, similar efficiency cannot be achieved for the face-splitting product.","category":"page"},{"location":"history/#What's-new-in-v3.8","page":"Version history","title":"What's new in v3.8","text":"","category":"section"},{"location":"history/","page":"Version history","title":"Version history","text":"A new map called InverseMap is introduced. Letting an InverseMap act on a vector is equivalent to solving the linear system, i.e. InverseMap(A) * b is the same as A \\ b. The default solver is ldiv!, but can be specified with the solver keyword argument to the constructor (see the docstring for details). Note that A must be compatible with the solver: A can, for example, be a factorization, or another LinearMap in combination with an iterative solver.\nNew constructors for lazy representations of Kronecker products (squarekron) and sums (sumkronsum) for square factors and summands, respectively, are introduced. They target cases with 3 or more factors/summands, and benchmarking intended use cases for comparison with KroneckerMap (constructed via Base.kron) and KroneckerSumMap (constructed via kronsum) is recommended.","category":"page"},{"location":"history/#What's-new-in-v3.7","page":"Version history","title":"What's new in v3.7","text":"","category":"section"},{"location":"history/","page":"Version history","title":"Version history","text":"mul!(M::AbstractMatrix, A::LinearMap, s::Number, a, b) methods are provided, mimicking similar methods in Base.LinearAlgebra. This version allows for the memory efficient implementation of in-place addition and conversion of a LinearMap to Matrix. Efficient specialisations for WrappedMap, ScaledMap, and LinearCombination are provided. If users supply the corresponding _unsafe_mul! method for their custom maps, conversion, construction, and inplace addition will benefit from this supplied efficient implementation. If no specialisation is supplied, a generic fallback is used that is based on feeding the canonical basis of unit vectors to the linear map.\nA new map type called EmbeddedMap is introduced. It is a wrapper of a \"small\" LinearMap (or a suitably converted AbstractVecOrMat) embedded into a \"larger\" zero map. Hence, the \"small\" map acts only on a subset of the coordinates and maps to another subset of the coordinates of the \"large\" map. The large map L can therefore be imagined as the composition of a sampling/projection map P, of the small map A, and of an embedding map E: L = E ⋅ A ⋅ P. It is implemented, however, by acting on a view of the vector x and storing the result into a view of the result vector y. Such maps can be constructed by the new methods:\nLinearMap(A::MapOrVecOrMat, dims::Dims{2}, index::NTuple{2, AbstractVector{Int}}), where dims is the dimensions of the \"large\" map and index is a tuple of the x- and y-indices that interact with A, respectively;\nLinearMap(A::MapOrVecOrMat, dims::Dims{2}; offset::Dims{2}), where the keyword argument offset determines the dimension of a virtual upper-left zero block, to which A gets (virtually) diagonally appended.\nAn often requested new feature has been added: slicing (i.e., non-scalar indexing) any LinearMap object via Base.getindex overloads. Note, however, that only rather efficient complete slicing operations are implemented: A[:,j], A[:,J], and A[:,:], where j::Integer and J is either of type AbstractVector{<:Integer>} or an AbstractVector{Bool} of appropriate length (\"logical slicing\"). Partial slicing operations such as A[I,j] and A[I,J] where I is as J above are disallowed.\nScalar indexing A[i::Integer,j::Integer] as well as other indexing operations that fall back on scalar indexing such as logical indexing by some AbstractMatrix{Bool}, or indexing by vectors of (linear or Cartesian) indices are not supported; as an exception, getindex calls on wrapped AbstractVecOrMats is forwarded to corresponding getindex methods from Base and therefore allow any type of usual indexing/slicing. If scalar indexing is really required, consider using A[:,j][i] which is as efficient as a reasonable generic implementation for LinearMaps can be.\nFurthermore, (predominantly) horizontal slicing operations require the adjoint operation of the LinearMap type to be defined, or will fail otherwise. Important note: LinearMap objects are meant to model objects that act on vectors efficiently, and are in general not backed up by storage-like types like Arrays. Therefore, slicing of LinearMaps is potentially slow, and it may require the (repeated) allocation of standard unit vectors. As a consequence, generic algorithms relying heavily on indexing and/or slicing are likely to run much slower than expected for AbstractArrays. To avoid repeated indexing operations which may involve redundant computations, it is strongly recommended to consider converting LinearMap-typed objects to Matrix or SparseMatrixCSC first, if memory permits.","category":"page"},{"location":"history/#What's-new-in-v3.6","page":"Version history","title":"What's new in v3.6","text":"","category":"section"},{"location":"history/","page":"Version history","title":"Version history","text":"Support for Julia versions below v1.6 has been dropped.\nBlock[Diagonal]Map, CompositeMap, KroneckerMap and LinearCombination type objects can now be backed by a Vector of LinearMap-type elements. This can be beneficial in cases where these higher-order LinearMaps are constructed from many maps where a tuple backend may get inefficient or impose hard work for the compiler at construction. The default behavior, however, does not change, and construction of vector-based LinearMaps requires usage of the unexported constructors (\"expert usage\"), except for constructions like sum([A, B, C]) or prod([A, B, C]) (== C*B*A), where A, B and C are of some LinearMap type.","category":"page"},{"location":"history/#What's-new-in-v3.5","page":"Version history","title":"What's new in v3.5","text":"","category":"section"},{"location":"history/","page":"Version history","title":"Version history","text":"WrappedMap, ScaledMap, LinearCombination, AdjointMap, TransposeMap and CompositeMap, instead of using the default axes(A) = map(oneto, size(A)), now forward calls to axes to the underlying wrapped linear map. This allows allocating operations such as * to determine the appropriate storage and axes type of their outputs. For example, linear maps that wrap BlockArrays will, upon multiplicative action, produce a BlockArrays.PseudoBlockVector with block structure inherited from the operator's output axes axes(A,1).","category":"page"},{"location":"history/#What's-new-in-v3.4","page":"Version history","title":"What's new in v3.4","text":"","category":"section"},{"location":"history/","page":"Version history","title":"Version history","text":"In WrappedMap constructors, as implicitly called in addition and mutliplication of LinearMaps and AbstractMatrix objects, (conjugate) symmetry and positive definiteness are only determined for matrix types for which these checks are expected to be very cheap or even known at compile time based on the concrete type. The default for LinearMap subtypes is to call, for instance, issymmetric, because symmetry properties are either stored or easily obtained from constituting maps. For custom matrix types, define corresponding methods LinearMaps._issymmetric, LinearMaps._ishermitian and LinearMaps._isposdef to hook into the property checking mechanism.","category":"page"},{"location":"history/#What's-new-in-v3.3","page":"Version history","title":"What's new in v3.3","text":"","category":"section"},{"location":"history/","page":"Version history","title":"Version history","text":"AbstractVectors can now be wrapped by a LinearMap just like AbstractMatrixtyped objects. Upon wrapping, they are not implicitly reshaped to matrices. This feature might be helpful, for instance, in the lazy representation of rank-1 operatorskron(LinearMap(u), v') == ⊗(u, v') == u ⊗ v'for vectorsuandv. The action on vectors,(u⊗v')x, is implemented optimally viau(v'x)`.","category":"page"},{"location":"history/#What's-new-in-v3.2","page":"Version history","title":"What's new in v3.2","text":"","category":"section"},{"location":"history/","page":"Version history","title":"Version history","text":"In-place left-multiplication mul!(Y, X, A::LinearMap) is now allowed for X::AbstractMatrix and implemented via the adjoint equation Y' = A'X'.","category":"page"},{"location":"history/#What's-new-in-v3.1","page":"Version history","title":"What's new in v3.1","text":"","category":"section"},{"location":"history/","page":"Version history","title":"Version history","text":"In Julia v1.3 and above, LinearMap-typed objects are callable on AbstractVectors: For L::LinearMap and x::AbstractVector, L(x) = L*x.","category":"page"},{"location":"history/#What's-new-in-v3.0","page":"Version history","title":"What's new in v3.0","text":"","category":"section"},{"location":"history/","page":"Version history","title":"Version history","text":"BREAKING change: Internally, any dependence on former A*_mul_B! methods is abandonned. For custom LinearMap subtypes, there are now two options:\nIn case your type is invariant under adjoint/transposition (i.e., adjoint(L::MyLinearMap)::MyLinearMap similar to, for instance, LinearCombinations or CompositeMaps), At_mul_B! and Ac_mul_B! do not require any replacement! Rather, multiplication by L' is, in this case, handled by mul!(y, L::MyLinearMap, x[, α, β]).\nOtherwise, you will need to define mul! methods with the signature mul!(y, L::TransposeMap{<:Any,MyLinearMap}, x[, α, β]) and mul!(y, L::AdjointMap{<:Any,MyLinearMap}, x[, α, β]).\nLeft multiplying by a transpose or adjoint vector (e.g., y'*A) produces a transpose or adjoint vector output, rather than a composite LinearMap.\nBlock concatenation now handles matrices and vectors directly by internal promotion to LinearMaps. For [h/v/hc]cat it suffices to have a LinearMap object anywhere in the list of arguments. For the block-diagonal concatenation via SparseArrays.blockdiag, a LinearMap object has to appear among the first 8 arguments. This restriction, however, does not apply to block-diagonal concatenation via Base.cat(As...; dims=(1,2)).\nIntroduction of more expressive and visually appealing show methods, replacing the fallback to the generic show.","category":"page"},{"location":"history/#What's-new-in-v2.7","page":"Version history","title":"What's new in v2.7","text":"","category":"section"},{"location":"history/","page":"Version history","title":"Version history","text":"Potential reduction of memory allocations in multiplication of LinearCombinations, BlockMaps, and real- or complex-scaled LinearMaps. For the latter, a new internal type ScaledMap has been introduced.\nMultiplication code for CompositeMaps has been refactored to facilitate to provide memory for storage of intermediate results by directly calling helper functions.","category":"page"},{"location":"history/#What's-new-in-v2.6","page":"Version history","title":"What's new in v2.6","text":"","category":"section"},{"location":"history/","page":"Version history","title":"Version history","text":"New feature: \"lazy\" Kronecker product, Kronecker sums, and powers thereof for LinearMaps. AbstractMatrix objects are promoted to LinearMaps if one of the first 8 Kronecker factors is a LinearMap object.\nCompatibility with the generic multiply-and-add interface (a.k.a. 5-arg mul!) introduced in julia v1.3","category":"page"},{"location":"history/#What's-new-in-v2.5","page":"Version history","title":"What's new in v2.5","text":"","category":"section"},{"location":"history/","page":"Version history","title":"Version history","text":"New feature: concatenation of LinearMaps objects with UniformScalings, consistent with (h-, v-, and hc-)concatenation of matrices. Note, matrices A must be wrapped as LinearMap(A), UniformScalings are promoted to LinearMaps automatically.","category":"page"},{"location":"history/#What's-new-in-v2.4","page":"Version history","title":"What's new in v2.4","text":"","category":"section"},{"location":"history/","page":"Version history","title":"Version history","text":"Support restricted to Julia v1.0+.","category":"page"},{"location":"history/#What's-new-in-v2.3","page":"Version history","title":"What's new in v2.3","text":"","category":"section"},{"location":"history/","page":"Version history","title":"Version history","text":"Fully Julia v0.7/v1.0/v1.1 compatible.\nFull support of noncommutative number types such as quaternions.","category":"page"},{"location":"history/#What's-new-in-v2.2","page":"Version history","title":"What's new in v2.2","text":"","category":"section"},{"location":"history/","page":"Version history","title":"Version history","text":"Fully Julia v0.7/v1.0 compatible.\nA convert(SparseMatrixCSC, A::LinearMap) function, that calls the sparse matrix generating function.","category":"page"},{"location":"history/#What's-new-in-v2.1","page":"Version history","title":"What's new in v2.1","text":"","category":"section"},{"location":"history/","page":"Version history","title":"Version history","text":"Fully Julia v0.7 compatible; dropped compatibility for previous versions of Julia from LinearMaps.jl v2.0.0 on.\nA 5-argument version for mul!(y, A::LinearMap, x, α=1, β=0), which computes y := α * A * x + β * y and implements the usual 3-argument mul!(y, A, x) for the default α and β.\nSynonymous convert(Matrix, A::LinearMap) and convert(Array, A::LinearMap) functions, that call the Matrix constructor and return the matrix representation of A.\nMultiplication with matrices, interpreted as a block row vector of vectors:\nmul!(Y::AbstractArray, A::LinearMap, X::AbstractArray, α=1, β=0): applies A to each column of X and stores the result in-place in the corresponding column of Y;\nfor the out-of-place multiplication, the approach is to compute convert(Matrix, A * X); this is equivalent to applying A to each column of X. In generic code which handles both A::AbstractMatrix and A::LinearMap, the additional call to convert is a noop when A is a matrix.\nFull compatibility with Arpack.jl's eigs and svds; previously only eigs was working. For more, nicely collaborating packages see the Example section.","category":"page"},{"location":"related/#Related-open-source-packages","page":"Related packages","title":"Related open-source packages","text":"","category":"section"},{"location":"related/","page":"Related packages","title":"Related packages","text":"The following open-source packages provide similar or even extended functionality as LinearMaps.jl.","category":"page"},{"location":"related/","page":"Related packages","title":"Related packages","text":"Spot: A linear-operator toolbox for Matlab, which seems to have heavily inspired the Julia package LinearOperators.jl and the Python package PyLops\nfastmat: fast linear transforms in Python\nJOLI.jl: Julia Operators LIbrary\nFunctionOperators.jl and LinearMapsAA.jl also support mappings between Arrays, inspired by the fatrix object type in the Matlab version of the Michigan Image Reconstruction Toolbox (MIRT).","category":"page"},{"location":"related/","page":"Related packages","title":"Related packages","text":"As for lazy array manipulation (like addition, composition, Kronecker products and concatenation), there exist further related packages in the Julia ecosystem:","category":"page"},{"location":"related/","page":"Related packages","title":"Related packages","text":"LazyArrays.jl\nBlockArrays.jl\nBlockDiagonals.jl\nBlockFactorizations.jl\nKronecker.jl\nFillArrays.jl\n`LiftedMaps.jl","category":"page"},{"location":"related/","page":"Related packages","title":"Related packages","text":"Since these packages provide types that are subtypes of Julia Base's AbstractMatrix type, objects of those types can be wrapped by a LinearMap and freely mixed with, for instance, function-based linear maps. The same applies to custom matrix types as provided, for instance, by packages maintained by the JuliaArrays github organization. For any CustomMatrix{T} <: AbstractMatrix{T} type, you only need to provide a mul!(::AbstractVecOrMat, ::CustomMatrix, ::AbstractVector[, ::Number, ::Number]) method for seamless integration with LinearMaps.jl.","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"EditURL = \"https://github.com/JuliaLinearAlgebra/LinearMaps.jl/blob/master/docs/src/custom.jl\"","category":"page"},{"location":"generated/custom/#Defining-custom-LinearMap-types","page":"Custom maps","title":"Defining custom LinearMap types","text":"","category":"section"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"In this section, we want to demonstrate on a simple, actually built-in, linear map type how to define custom LinearMap subtypes. First of all, LinearMap{T} is an extendable abstract type, where T denotes the eltype.","category":"page"},{"location":"generated/custom/#Basics","page":"Custom maps","title":"Basics","text":"","category":"section"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"As an example, we want to define a map type whose objects correspond to lazy analogues of filled matrices. Naturally, we need to store the filled value λ and the size of the linear map.","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"using LinearMaps, LinearAlgebra\n\nstruct MyFillMap{T} <: LinearMaps.LinearMap{T}\n    λ::T\n    size::Dims{2}\n    function MyFillMap(λ::T, dims::Dims{2}) where {T}\n        all(≥(0), dims) || throw(ArgumentError(\"dims of MyFillMap must be non-negative\"))\n        promote_type(T, typeof(λ)) == T || throw(InexactError())\n        return new{T}(λ, dims)\n    end\nend","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"By default, for any A::MyFillMap{T}, eltype(A) returns T. Upon application to a vector x and/or interaction with other LinearMap objects, we need to check consistent sizes.","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"Base.size(A::MyFillMap) = A.size","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"By a couple of defaults provided for all subtypes of LinearMap, we only need to define a LinearMaps._unsafe_mul! method to have a minimal, operational type. The (internal) function _unsafe_mul! is called by LinearAlgebra.mul!, constructors, and conversions and only needs to be concerned with the bare computing kernel. Dimension checking is done on the level of mul! etc. Factoring out dimension checking is done to minimise overhead caused by repetitive checking.","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"note: Note\nMultiple dispatch at the _unsafe_mul! level happens via the second (the map type) and the third arguments (AbstractVector or AbstractMatrix, see the Application to matrices section below). For that reason, the output argument can remain type-unbound.","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"function LinearMaps._unsafe_mul!(y, A::MyFillMap, x::AbstractVector)\n    return fill!(y, iszero(A.λ) ? zero(eltype(y)) : A.λ*sum(x))\nend","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"Again, due to generic fallbacks the following now \"just work\":","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"out-of-place multiplication A*x,\nin-place multiplication with vectors mul!(y, A, x),\nin-place multiply-and-add with vectors mul!(y, A, x, α, β),\nin-place multiplication and multiply-and-add with matrices mul!(Y, A, X, α, β),\nconversion to a (sparse) matrix Matrix(A) and sparse(A),\ncomplete slicing of columns (and rows if the adjoint action is defined).","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"A = MyFillMap(5.0, (3, 3)); x = ones(3); sum(x)","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"A * x","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"mul!(zeros(3), A, x)","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"mul!(ones(3), A, x, 2, 2)","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"mul!(ones(3,3), A, reshape(collect(1:9), 3, 3), 2, 2)","category":"page"},{"location":"generated/custom/#Multiply-and-add-and-the-MulStyle-trait","page":"Custom maps","title":"Multiply-and-add and the MulStyle trait","text":"","category":"section"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"While the above function calls work out of the box due to generic fallbacks, the latter may be suboptimally implemented for your custom map type. Let's see some benchmarks.","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"using BenchmarkTools\n\n@benchmark mul!($(zeros(3)), $A, $x)","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"@benchmark mul!($(zeros(3)), $A, $x, $(rand()), $(rand()))","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"The second benchmark indicates the allocation of an intermediate vector z which stores the result of A*x before it gets scaled and added to (the scaled) y = zeros(3). For that reason, it is beneficial to provide a custom \"5-arg _unsafe_mul!\" if you can avoid the allocation of an intermediate vector. To indicate that there exists an allocation-free implementation of multiply-and-add, you should set the MulStyle trait, whose default is ThreeArg(), to FiveArg().","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"LinearMaps.MulStyle(A::MyFillMap) = FiveArg()\n\nfunction LinearMaps._unsafe_mul!(y, A::MyFillMap, x::AbstractVector, α, β)\n    if iszero(α)\n        !isone(β) && rmul!(y, β)\n        return y\n    else\n        temp = A.λ * sum(x) * α\n        if iszero(β)\n            y .= temp\n        elseif isone(β)\n            y .+= temp\n        else\n            y .= y .* β .+ temp\n        end\n    end\n    return y\nend","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"With this function at hand, let's redo the benchmark.","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"@benchmark mul!($(zeros(3)), $A, $x, $(rand()), $(rand()))","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"There you go, the allocation is gone and the computation time is significantly reduced.","category":"page"},{"location":"generated/custom/#Adjoints-and-transposes","page":"Custom maps","title":"Adjoints and transposes","text":"","category":"section"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"Generically, taking the transpose (or the adjoint) of a (real, resp.) map wraps the linear map by a TransposeMap, taking the adjoint of a complex map wraps it by an AdjointMap.","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"typeof(A')","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"Not surprisingly, without further definitions, multiplying A' by x yields an error.","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"try A'x catch e println(e) end","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"If the operator is symmetric or Hermitian, the transpose and the adjoint, respectively, of the linear map A is given by A itself. So let us define corresponding checks.","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"LinearAlgebra.issymmetric(A::MyFillMap) = A.size[1] == A.size[2]\nLinearAlgebra.ishermitian(A::MyFillMap) = isreal(A.λ) && A.size[1] == A.size[2]\nLinearAlgebra.isposdef(A::MyFillMap) = (size(A, 1) == size(A, 2) == 1 && isposdef(A.λ))\nBase.:(==)(A::MyFillMap, B::MyFillMap) = A.λ == B.λ && A.size == B.size","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"These are used, for instance, in checking symmetry or positive definiteness of higher-order LinearMaps, like products or linear combinations of linear maps, or signal to iterative eigenproblem solvers that real eigenvalues are to be computed. Without these definitions, the first three functions would return false (by default), and the last one would fall back to ===.","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"With this at hand, we note that A above is symmetric, and we can compute","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"transpose(A)*x","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"This, however, does not work for nonsquare maps","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"try MyFillMap(5.0, (3, 4))' * ones(3) catch e println(e) end","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"which require explicit adjoint/transpose handling, for which there exist two distinct paths.","category":"page"},{"location":"generated/custom/#Path-1:-Generic,-non-invariant-LinearMap-subtypes","page":"Custom maps","title":"Path 1: Generic, non-invariant LinearMap subtypes","text":"","category":"section"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"The first option is to write LinearMaps._unsafe_mul! methods for the corresponding wrapped map types; for instance,","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"function LinearMaps._unsafe_mul!(\n    y,\n    transA::LinearMaps.TransposeMap{<:Any,<:MyFillMap},\n    x::AbstractVector\n)\n    λ = transA.lmap.λ\n    return fill!(y, iszero(λ) ? zero(eltype(y)) : transpose(λ)*sum(x))\nend","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"Now, the adjoint multiplication works.","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"MyFillMap(5.0, (3, 4))' * ones(3)","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"If you have set the MulStyle trait to FiveArg(), you should provide a corresponding 5-arg mul! method for LinearMaps.TransposeMap{<:Any,<:MyFillMap} and LinearMaps.AdjointMap{<:Any,<:MyFillMap}.","category":"page"},{"location":"generated/custom/#Path-2:-Invariant-LinearMap-subtypes","page":"Custom maps","title":"Path 2: Invariant LinearMap subtypes","text":"","category":"section"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"Before we start, let us delete the previously defined method to make sure we use the following definitions.","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"Base.delete_method(\n    first(methods(\n        LinearMaps._unsafe_mul!,\n        (Any, LinearMaps.TransposeMap{<:Any,<:MyFillMap}, AbstractVector))\n    )\n)","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"The seconnd option is when your class of linear maps that are modelled by your custom LinearMap subtype are invariant under taking adjoints and transposes.","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"LinearAlgebra.adjoint(A::MyFillMap) = MyFillMap(adjoint(A.λ), reverse(A.size))\nLinearAlgebra.transpose(A::MyFillMap) = MyFillMap(transpose(A.λ), reverse(A.size))","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"With such invariant definitions, i.e., the adjoint/transpose of a MyFillMap is again a MyFillMap, no further method definitions are required, and the entire functionality listed above just works for adjoints/transposes of your custom map type.","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"mul!(ones(3), A', x, 2, 2)","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"MyFillMap(5.0, (3, 4))' * ones(3)","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"Now that we have defined the action of adjoints/transposes, the following right action on vectors is automatically defined:","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"ones(3)' * MyFillMap(5.0, (3, 4))","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"and transpose(x) * A correspondingly, as well as in-place multiplication","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"mul!(similar(x)', x', A)","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"and mul!(transpose(y), transpose(x), A).","category":"page"},{"location":"generated/custom/#Application-to-matrices","page":"Custom maps","title":"Application to matrices","text":"","category":"section"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"By default, applying a LinearMap A to a matrix X via A*X does not apply A to each column of X viewed as a vector, but interprets X as a linear map, wraps it as such and returns (A*X)::CompositeMap. Calling the in-place multiplication function mul!(Y, A, X) for matrices, however, does compute the columnwise action of A on X and stores the result in Y. In case there is a more efficient implementation for the matrix application, you can provide _unsafe_mul! methods with signature _unsafe_mul!(Y, A::MyFillMap, X::AbstractMatrix), and, depending on the chosen path to handle adjoints/transposes, corresponding methods for wrapped maps of type AdjointMap or TransposeMap, plus potentially corresponding 5-arg mul! methods. This may seem like a lot of methods to be implemented, but note that adding such methods is only necessary/recommended for increased performance.","category":"page"},{"location":"generated/custom/#Computing-a-matrix-representation","page":"Custom maps","title":"Computing a matrix representation","text":"","category":"section"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"In some cases, it might be necessary to compute a matrix representation of a LinearMap. This is essentially done via the [LinearMaps._unsafe_mul!(::Matrix,::LinearMap,::Number)](@ref) method, for which a generic fallback exists: it applies the LinearMap successively to the standard unit vectors.","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"F = MyFillMap(5, (100,100))\nM = Matrix{eltype(F)}(undef, size(F))\n@benchmark Matrix($F)","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"@benchmark LinearMaps._unsafe_mul!($(Matrix{Int}(undef, (100,100))), $(MyFillMap(5, (100,100))), true)","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"If a more performant implementation exists, it is recommended to overwrite this method, for instance (as before, size checks need not be included here since they are handled by the corresponding LinearAlgebra.mul! method):","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"LinearMaps._unsafe_mul!(M, A::MyFillMap, s::Number) = fill!(M, A.λ*s)\n@benchmark Matrix($F)","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"@benchmark LinearMaps._unsafe_mul!($(Matrix{Int}(undef, (100,100))), $(MyFillMap(5, (100,100))), true)","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"As one can see, the above runtimes are dominated by the allocation of the output matrix, but still overwriting the multiplication kernel yields a speed-up of about factor 3 for the matrix filling part.","category":"page"},{"location":"generated/custom/#Slicing","page":"Custom maps","title":"Slicing","text":"","category":"section"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"As usual, generic fallbacks for LinearMap slicing exist and are handled by the following method hierarchy, where at least one of I and J has to be a Colon:","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"Base.getindex(::LinearMap, I, J)\n-> LinearMaps._getindex(::LinearMap, I, J)","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"The method Base.getindex checks the validity of the the requested indices and calls LinearMaps._getindex, which should be overloaded for custom LinearMaps subtypes. For instance:","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"@benchmark F[1,:]","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"LinearMaps._getindex(A::MyFillMap, ::Integer, J::Base.Slice) = fill(A.λ, axes(J))\n@benchmark F[1,:]","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"Note that in Base.getindex Colons are converted to Base.Slice via Base.to_indices, thus the dispatch must be on Base.Slice rather than on Colon.","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#LinearMaps.jl","page":"Home","title":"LinearMaps.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package for defining and working with linear maps, also known as linear transformations or linear operators acting on vectors. The only requirement for a LinearMap is that it can act on a vector (by multiplication) efficiently.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"LinearMaps.jl is a registered package and can be installed via","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add LinearMaps","category":"page"},{"location":"","page":"Home","title":"Home","text":"in package mode, which can be entered by typing ] in the Julia REPL.","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Let","category":"page"},{"location":"","page":"Home","title":"Home","text":"A = LinearMap(rand(10, 10))\nB = LinearMap(cumsum, reverse∘cumsum∘reverse, 10)","category":"page"},{"location":"","page":"Home","title":"Home","text":"be a matrix- and function-based linear map, respectively. Then the following code just works, indistinguishably from the case when A and B are both AbstractMatrix-typed objects.","category":"page"},{"location":"","page":"Home","title":"Home","text":"3.0A + 2B\nA + I\nA*B'\n[A B; B A]\nkron(A, B)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The LinearMap type and corresponding methods combine well with the following packages:","category":"page"},{"location":"","page":"Home","title":"Home","text":"ArnoldiMethods.jl\nArpack.jl: iterative eigensolver eigs and SVD svds;\nIterativeSolvers.jl: iterative solvers, eigensolvers, and SVD;\nKrylovKit.jl: Krylov-based algorithms for linear problems, singular value and eigenvalue problems\nTSVD.jl: truncated SVD tsvd.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using LinearMaps\nimport Arpack, IterativeSolvers, KrylovKit, TSVD, ArnoldiMethod\n\n# Example 1, 1-dimensional Laplacian with periodic boundary conditions\nfunction leftdiff!(y::AbstractVector, x::AbstractVector) # left difference assuming periodic boundary conditions\n    N = length(x)\n    axes(y) == axes(x) || throw(DimensionMismatch())\n    @inbounds for i in eachindex(x, y)\n        y[i] = x[i] - x[mod1(i-1, N)]\n    end\n    return y\nend\n\nfunction mrightdiff!(y::AbstractVector, x::AbstractVector) # minus right difference\n    N = length(x)\n    axes(y) == axes(x) || throw(DimensionMismatch())\n    @inbounds for i in eachindex(x, y)\n        y[i] = x[i] - x[mod1(i+1, N)]\n    end\n    return y\nend\n\nD = LinearMap(leftdiff!, mrightdiff!, 100; ismutating=true) # by default has eltype(D) = Float64\n\nArpack.eigs(D'D; nev=3, which=:SR) # note that D'D is recognized as symmetric => real eigenfact\nArpack.svds(D; nsv=3)\n\nArnoldiMethod.partialschur(D'D; nev=3, which=ArnoldiMethod.SR())\n\nKrylovKit.eigsolve(D'D, 100, 3, :SR)\n\nΣ, L = IterativeSolvers.svdl(D; nsv=3)\n\nTSVD.tsvd(D, 3)\n\n# Example 2, 3 smallest eigenvalues of 1-dimensional Laplacian\nA = LinearMap(100; issymmetric=true, ismutating=true) do C, B\n    C[1] = -2B[1] + B[2]\n    for i in 2:length(B)-1\n        C[i] = B[i-1] - 2B[i] + B[i+1]\n    end\n    C[end] = B[end-1] - 2B[end]\n    return C\nend\n\nArpack.eigs(-A; nev=3, which=:SR)\n\nArnoldiMethod.partialschur(-A; nev=3, which=ArnoldiMethod.SR())\n\nKrylovKit.eigsolve(-A, size(A, 1), 3, :SR)\n\n# Example 3, 2-dimensional Laplacian\nΔ = kronsum(A, A)\n\nArpack.eigs(Δ; nev=3, which=:LR)\nArnoldiMethod.partialeigen(ArnoldiMethod.partialschur(Δ; nev=3, which=ArnoldiMethod.LR())[1])\nKrylovKit.eigsolve(Δ, size(Δ, 1), 3, :LR)","category":"page"},{"location":"","page":"Home","title":"Home","text":"In the last line above we leverage the fact that objects of type L <: LinearMap are callable.","category":"page"},{"location":"#Inverse-map-with-conjugate-gradient","page":"Home","title":"Inverse map with conjugate gradient","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The InverseMap type can be used to lazily represent the inverse of an operator. When this map acts on a vector the linear system is solved. This can be used to solve a system of the form Sx = (C A^-1 B) x = b without explicitly computing A^-1 (see for example solving a linear system using the Schur complement).","category":"page"},{"location":"","page":"Home","title":"Home","text":"using LinearMaps, IterativeSolvers\n\nA = [2.0 1.5 0.0\n     1.5 3.0 0.0\n     0.0 0.0 4.0]\nB = [2.0 0.0\n     0.0 1.0\n     0.0 0.0]\nC = B'\nb = [2.0, 3.0]\n\n# Use IterativeSolvers.cg! to solve the system with 0 as the initial guess\nlinsolve = (x, A, b) -> IterativeSolvers.cg!(fill!(x, 0), A, b)\n\n# Construct the linear map S\nS = C * InverseMap(A; solver=linsolve) * B\n\n# Solve the system\nIterativeSolvers.cg(S, b)","category":"page"},{"location":"","page":"Home","title":"Home","text":"In every CG iteration the linear map S will act on a vector v. Since S is a composed linear map, S * v is roughly equivalent to","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Apply first linear map B to v\ntmp1 = B * v\n# Apply second linear map: solve linear system with vector tmp1 as RHS\ntmp2 = A \\ tmp1\n# Apply third linear map C to tmp2\nresult = C * tmp2","category":"page"},{"location":"","page":"Home","title":"Home","text":"i.e. inside the CG solver for solving Sx = b we use CG to solve another inner linear system.","category":"page"},{"location":"#Philosophy","page":"Home","title":"Philosophy","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Several iterative linear algebra methods such as linear solvers or eigensolvers only require an efficient evaluation of the matrix-vector product, where the concept of a matrix can be formalized / generalized to a linear map (or linear operator in the special case of a square matrix).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The LinearMaps package provides the following functionality:","category":"page"},{"location":"","page":"Home","title":"Home","text":"A LinearMap type that shares with the AbstractMatrix type that it responds to the functions size, eltype, isreal, issymmetric, ishermitian and isposdef, transpose and adjoint and multiplication with a vector using both * or the in-place version mul!. Linear algebra functions that use duck-typing for their arguments can handle LinearMap objects similar to AbstractMatrix objects, provided that they can be written using the above methods. Unlike AbstractMatrix types, LinearMap objects cannot be indexed, neither using getindex or setindex!.\nA single function LinearMap that acts as a general purpose constructor (though it is only an abstract type) and allows to construct linear map objects from functions, or to wrap objects of type AbstractMatrix or LinearMap. The latter functionality is useful to (re)define the properties (isreal, issymmetric, ishermitian, isposdef) of the existing matrix or linear map.\nA framework for combining objects of type LinearMap and of type AbstractMatrix using linear combinations, transposition, composition, concatenation and Kronecker product/sums, where the linear map resulting from these operations is never explicitly evaluated but only its matrix-vector product is defined (i.e. lazy evaluation). The matrix-vector product is written to minimize memory allocation by using a minimal number of temporary vectors. There is full support for the in-place version mul!, which should be preferred for higher efficiency in critical algorithms. In addition, it tries to recognize the properties of combinations of linear maps. In particular, compositions such as A'*A for arbitrary A or even A'*B*C*B'*A with arbitrary A and B and positive definite C are recognized as being positive definite and hermitian. In case a certain property of the resulting LinearMap object is not correctly inferred, the LinearMap method can be called to redefine the properties.","category":"page"},{"location":"types/#Types-and-methods","page":"Types and methods","title":"Types and methods","text":"","category":"section"},{"location":"types/#Types-and-their-constructors","page":"Types and methods","title":"Types and their constructors","text":"","category":"section"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"None of the types below need to be constructed directly; they arise from performing operations between LinearMap objects or by calling the LinearMap constructor described next.","category":"page"},{"location":"types/#LinearMap","page":"Types and methods","title":"LinearMap","text":"","category":"section"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"Abstract supertype","category":"page"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"LinearMap","category":"page"},{"location":"types/#LinearMaps.LinearMap","page":"Types and methods","title":"LinearMaps.LinearMap","text":"LinearMap(A::LinearMap; kwargs...)::WrappedMap\nLinearMap(A::AbstractVecOrMatOrQ; kwargs...)::WrappedMap\nLinearMap(J::UniformScaling, M::Int)::UniformScalingMap\nLinearMap{T=Float64}(f, [fc,], M::Int, N::Int = M; kwargs...)::FunctionMap\nLinearMap(A::MapOrVecOrMat, dims::Dims{2}, index::NTuple{2, AbstractVector{Int}})::EmbeddedMap\nLinearMap(A::MapOrVecOrMat, dims::Dims{2}; offset::Dims{2})::EmbeddedMap\n\nConstruct a linear map object, either\n\nfrom an existing LinearMap or AbstractVecOrMat/AbstractQ A, with the purpose of\n\nredefining its properties via the keyword arguments kwargs, see below;\n\na UniformScaling object J with specified (square) dimension M;\nfrom a function or callable object f;\nfrom an existing LinearMap or AbstractVecOrMat/AbstractQ A, embedded in a larger zero map.\n\nIn the case of item 3, one also needs to specify the size of the equivalent matrix representation (M, N), i.e., for functions f acting on length N vectors and producing length M vectors (with default value N=M). Preferably, also the eltype T of the corresponding matrix representation needs to be specified, i.e., whether the action of f on a vector will be similar to, e.g., multiplying by numbers of type T. If not specified, the devault value T=Float64 will be assumed. Optionally, a corresponding function fc can be specified that implements the adjoint (or transpose in the real case) of f.\n\nThe keyword arguments and their default values are:\n\nissymmetric::Bool = false : whether A or f act as a symmetric matrix\nishermitian::Bool = issymmetric & T<:Real : whether A or f act as a Hermitian matrix\nisposdef::Bool = false : whether A or f act as a positive definite matrix.\n\nFor existing linear maps or matrices A, the default values will be taken by calling internal functions _issymmetric, _ishermitian and _isposdef on the existing object A. These in turn dispatch to (overloads of) LinearAlgebra's issymmetric, ishermitian, and isposdef methods whenever these checks are expected to be computationally cheap or even known at compile time as for certain structured matrices, but return false for generic AbstractMatrix types.\n\nFor the function-based constructor, there is one more keyword argument:\n\nismutating::Bool : flags whether the function acts as a mutating matrix multiplication f(y,x) where the result vector y is the first argument (in case of true), or as a normal matrix multiplication that is called as y=f(x) (in case of false). The default value is guessed by looking at the number of arguments of the first occurrence of f in the method table.\n\nFor the EmbeddedMap constructors, dims specifies the total dimensions of the map. The index argument specifies two collections of indices inds1 and inds2, such that for the big zero map L (thought of as a matrix), one has L[inds1,inds2] == A. In other words, inds1 specifies the output indices, inds2 specifies the input indices. Alternatively, A may be shifted by offset, such that (thinking in terms of matrices again) L[offset[1] .+ axes(A, 1), offset[2] .+ axes(A, 2)] == A.\n\n\n\n\n\n","category":"type"},{"location":"types/#FunctionMap","page":"Types and methods","title":"FunctionMap","text":"","category":"section"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"Type for wrapping an arbitrary function that is supposed to implement the matrix-vector product as a LinearMap; see above.","category":"page"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"FunctionMap","category":"page"},{"location":"types/#LinearMaps.FunctionMap","page":"Types and methods","title":"LinearMaps.FunctionMap","text":"FunctionMap{T,iip}(f, [fc,], M, N = M; kwargs...)\n\nConstruct a FunctionMap object from a function or callable object f that represents a linear map of size (M, N), where N can be omitted for square operators of size (M,M). Furthermore, the eltype T of the corresponding matrix representation needs to be specified, i.e., whether the action of f on a vector will be similar to, e.g., multiplying by numbers of type T. Optionally, a second function fc can be specified that implements the adjoint (or transpose in the real case) of f.\n\nAccepted keyword arguments and their default values are as in the LinearMap constructor.\n\nExamples\n\n```jldoctest julia> F = FunctionMap{Int64,false}(cumsum, 2) 2×2 FunctionMap{Int64,false}(cumsum; issymmetric=false, ishermitian=false, isposdef=false)\n\njulia> F * ones(Int64, 2) 2-element Vector{Int64}:  1  2\n\njulia> Matrix(F) 2×2 Matrix{Int64}:  1  0  1  1\n\n\n\n\n\n","category":"type"},{"location":"types/#WrappedMap","page":"Types and methods","title":"WrappedMap","text":"","category":"section"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"Type for wrapping an AbstractMatrix or LinearMap and to possible redefine the properties isreal, issymmetric, ishermitian and isposdef. An AbstractMatrix will automatically be converted to a WrappedMap when it is combined with other LinearMap objects via linear combination or composition (multiplication). Note that WrappedMap(mat1)*WrappedMap(mat2) will never evaluate mat1*mat2, since this is more costly than evaluating mat1*(mat2*x) and the latter is the only operation that needs to be performed by LinearMap objects anyway. While the cost of matrix addition is comparable to matrix-vector multiplication, this too is not performed explicitly since this would require new storage of the same amount as of the original matrices.","category":"page"},{"location":"types/#ScaledMap","page":"Types and methods","title":"ScaledMap","text":"","category":"section"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"Type for representing a scalar multiple of any LinearMap type. A ScaledMap will be automatically constructed if real or complex LinearMap objects are multiplied by real or complex scalars from the left or from the right.","category":"page"},{"location":"types/#UniformScalingMap","page":"Types and methods","title":"UniformScalingMap","text":"","category":"section"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"Type for representing a scalar multiple of the identity map (a.k.a. uniform scaling) of a certain size M=N, obtained simply as LinearMap(λI, M), where I is the LinearAlgebra.UniformScaling object. The type T of the resulting LinearMap object is inferred from the type of λ. A UniformScalingMap of the correct size will be automatically constructed if LinearMap objects are multiplied by scalars from the left or from the right (respecting the order of multiplication), if the scalar λ is either real or complex.","category":"page"},{"location":"types/#LinearCombination,-CompositeMap,-TransposeMap-and-AdjointMap","page":"Types and methods","title":"LinearCombination, CompositeMap, TransposeMap and AdjointMap","text":"","category":"section"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"Used to add/multiply/transpose/adjoint LinearMap objects lazily, don't need to be constructed explicitly.","category":"page"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"+(::LinearMap,::LinearMap)\n*(::LinearMap,::LinearMap)\nLinearAlgebra.transpose(::LinearMap)\nLinearAlgebra.adjoint(::LinearMap)","category":"page"},{"location":"types/#Base.:+-Tuple{LinearMap, LinearMap}","page":"Types and methods","title":"Base.:+","text":"+(A::LinearMap, B::LinearMap)::LinearCombination\n\nConstruct a (lazy) representation of the sum/linear combination of the two operators. Sums of LinearMap/LinearCombination objects and LinearMap/LinearCombination objects are reduced to a single LinearCombination. In sums of LinearMaps and AbstractMatrix/UniformScaling objects, the latter get promoted to LinearMaps automatically.\n\nExamples\n\njulia> CS = LinearMap{Int}(cumsum, 3)::LinearMaps.FunctionMap;\n\njulia> LinearMap(ones(Int, 3, 3)) + CS + I + rand(3, 3);\n\n\n\n\n\n","category":"method"},{"location":"types/#Base.:*-Tuple{LinearMap, LinearMap}","page":"Types and methods","title":"Base.:*","text":"*(A::LinearMap, B::LinearMap)::CompositeMap\n\nConstruct a (lazy) representation of the product of the two operators. Products of LinearMap/CompositeMap objects and LinearMap/CompositeMap objects are reduced to a single CompositeMap. In products of LinearMaps and AbstractMatrix/UniformScaling objects, the latter get promoted to LinearMaps automatically.\n\nExamples\n\njulia> CS = LinearMap{Int}(cumsum, 3)::LinearMaps.FunctionMap;\n\njulia> LinearMap(ones(Int, 3, 3)) * CS * I * rand(3, 3);\n\n\n\n\n\n","category":"method"},{"location":"types/#Base.transpose-Tuple{LinearMap}","page":"Types and methods","title":"Base.transpose","text":"transpose(A::LinearMap)\n\nConstruct a lazy representation of the transpose of A. This can be either a TransposeMap wrapper of A, or a suitably redefined instance of the same type as A. For instance, for a linear combination of linear maps A + B, the transpose is given by A^ + B^, i.e., another linear combination of linear maps.\n\n\n\n\n\n","category":"method"},{"location":"types/#Base.adjoint-Tuple{LinearMap}","page":"Types and methods","title":"Base.adjoint","text":"adjoint(A::LinearMap)\n\nConstruct a lazy representation of the adjoint of A. This can be either a AdjointMap wrapper of A, or a suitably redefined instance of the same type as A. For instance, for a linear combination of linear maps A + B, the adjoint is given by A^* + B^*, i.e., another linear combination of linear maps.\n\n\n\n\n\n","category":"method"},{"location":"types/#KroneckerMap-and-KroneckerSumMap","page":"Types and methods","title":"KroneckerMap and KroneckerSumMap","text":"","category":"section"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"Types for representing Kronecker products and Kronecker sums, resp., lazily.","category":"page"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"Base.kron(::LinearMap,::LinearMap)\nLinearMaps.:⊗\nkronsum\nLinearMaps.:⊕","category":"page"},{"location":"types/#Base.kron-Tuple{LinearMap, LinearMap}","page":"Types and methods","title":"Base.kron","text":"kron(A::LinearMap, B::LinearMap)::KroneckerMap\nkron(A, B, Cs...)::KroneckerMap\n\nConstruct a (lazy) representation of the Kronecker product A⊗B. One of the two factors can be an AbstractMatrix, which is then promoted to a LinearMap automatically.\n\nTo avoid fallback to the generic Base.kron in the multi-map case, there must be a LinearMap object among the first 8 arguments in usage like kron(A, B, Cs...).\n\nFor convenience, one can also use A ⊗ B or ⊗(A, B, Cs...) (typed as \\otimes+TAB) to construct the KroneckerMap, even when all arguments are of AbstractMatrix type.\n\nIf A, B, C and D are linear maps of such size that one can form the matrix products A*C and B*D, then the mixed-product property (A⊗B)*(C⊗D) = (A*C)⊗(B*D) holds. Upon vector multiplication, this rule is checked for applicability.\n\nExamples\n\njulia> J = LinearMap(I, 2) # 2×2 identity map\n2×2 LinearMaps.UniformScalingMap{Bool} with scaling factor: true\n\njulia> E = spdiagm(-1 => trues(1)); D = E + E' - 2I;\n\njulia> Δ = kron(D, J) + kron(J, D); # discrete 2D-Laplace operator\n\njulia> Matrix(Δ)\n4×4 Array{Int64,2}:\n -4   1   1   0\n  1  -4   0   1\n  1   0  -4   1\n  0   1   1  -4\n\n\n\n\n\n","category":"method"},{"location":"types/#LinearMaps.:⊗","page":"Types and methods","title":"LinearMaps.:⊗","text":"⊗(k::Integer)\n\nConstruct a lazy representation of the k-th Kronecker power A^⊗(k) = A ⊗ A ⊗ ... ⊗ A, where A can be an AbstractMatrix or a LinearMap.\n\n\n\n\n\n","category":"function"},{"location":"types/#LinearMaps.kronsum","page":"Types and methods","title":"LinearMaps.kronsum","text":"kronsum(A, B)::KroneckerSumMap\nkronsum(A, B, Cs...)::KroneckerSumMap\n\nConstruct a (lazy) representation of the Kronecker sum A⊕B = A ⊗ Ib + Ia ⊗ B of two square linear maps of type LinearMap or AbstractMatrix. Here, Ia and Ib are identity operators of the size of A and B, respectively. Arguments of type AbstractMatrix are automatically promoted to LinearMap.\n\nFor convenience, one can also use A ⊕ B or ⊕(A, B, Cs...) (typed as \\oplus+TAB) to construct the KroneckerSumMap.\n\nExamples\n\njulia> J = LinearMap(I, 2) # 2×2 identity map\n2×2 LinearMaps.UniformScalingMap{Bool} with scaling factor: true\n\njulia> E = spdiagm(-1 => trues(1)); D = LinearMap(E + E' - 2I);\n\njulia> Δ₁ = kron(D, J) + kron(J, D); # discrete 2D-Laplace operator, Kronecker sum\n\njulia> Δ₂ = kronsum(D, D);\n\njulia> Δ₃ = D^⊕(2);\n\njulia> Matrix(Δ₁) == Matrix(Δ₂) == Matrix(Δ₃)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"types/#LinearMaps.:⊕","page":"Types and methods","title":"LinearMaps.:⊕","text":"⊕(k::Integer)\n\nConstruct a lazy representation of the k-th Kronecker sum power A^⊕(k) = A ⊕ A ⊕ ... ⊕ A, where A can be a square AbstractMatrix or a LinearMap. This calls sumkronsum on the k-tuple (A, ..., A) for k ≥ 3.\n\nExample\n\n```jldoctest julia> Matrix([1 0; 0 1]^⊕(2)) 4×4 Matrix{Int64}:  2  0  0  0  0  2  0  0  0  0  2  0  0  0  0  2\n\n\n\n\n\n","category":"function"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"There exist alternative constructors of Kronecker products and sums for square factors and summands, respectively. These are designed for cases of 3 or more arguments, and benchmarking intended use cases for comparison with KroneckerMap and KroneckerSumMap is recommended.","category":"page"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"squarekron\nsumkronsum","category":"page"},{"location":"types/#LinearMaps.squarekron","page":"Types and methods","title":"LinearMaps.squarekron","text":"squarekron(A₁::MapOrMatrix, A₂::MapOrMatrix, A₃::MapOrMatrix, Aᵢ::MapOrMatrix...)::CompositeMap\n\nConstruct a (lazy) representation of the Kronecker product ⨂ᵢ₌₁ⁿ Aᵢ of at least 3 square Kronecker factors. In contrast to kron, this function assumes that all Kronecker factors are square, and makes use of the following identity[1]:\n\nbigotimes_i=1^n A_i = prod_i=1^n I_1 otimes ldots otimes I_i-1 otimes A_i otimes I_i+1 otimes ldots otimes I_n\n\nwhere I_k is an identity matrix of the size of A_k. By associativity, the Kronecker product of the identity operators may be combined to larger identity operators I_1i-1 and I_i+1n, which yields\n\nbigotimes_i=1^n A_i = prod_i=1^n I_1i-1 otimes A_i otimes I_i+1n\n\ni.e., a CompositeMap where each factor is a Kronecker product consisting of three maps: outer UniformScalingMaps and the respective Kronecker factor. This representation is expected to yield significantly faster multiplication (and reduce memory allocation) compared to kron, but benchmarking intended use cases is highly recommended.\n\n[1]: Fernandes, P. and Plateau, B. and Stewart, W. J. \"Efficient Descriptor-Vector Multiplications in Stochastic Automata Networks\", Journal of the ACM, 45(3), 381–414, 1998.\n\n\n\n\n\n","category":"function"},{"location":"types/#LinearMaps.sumkronsum","page":"Types and methods","title":"LinearMaps.sumkronsum","text":"sumkronsum(A, B)::LinearCombination\nsumkronsum(A, B, Cs...)::LinearCombination\n\nConstruct a (lazy) representation of the Kronecker sum A⊕B of two or more square objects of type LinearMap or AbstractMatrix. This function makes use of the following representation of Kronecker sums[1]:\n\nbigoplus_i=1^n A_i = sum_i=1^n I_1 otimes ldots otimes I_i-1 otimes A_i otimes I_i+1 otimes ldots otimes I_n\n\nwhere I_k is the identity operator of the size of A_k. By associativity, the Kronecker product of the identity operators may be combined to larger identity operators I_1i-1 and I_i+1n, which yields\n\nbigoplus_i=1^n A_i = sum_i=1^n I_1i-1 otimes A_i otimes I_i+1n\n\ni.e., a LinearCombination where each summand is a Kronecker product consisting of three maps: outer UniformScalingMaps and the respective Kronecker factor. This representation is expected to yield significantly faster multiplication (and reduce memory allocation) compared to kronsum, especially for 3 or more Kronecker summands, but benchmarking intended use cases is highly recommended.\n\nExamples\n\njulia> J = LinearMap(I, 2) # 2×2 identity map\n2×2 LinearMaps.UniformScalingMap{Bool} with scaling factor: true\n\njulia> E = spdiagm(-1 => trues(1)); D = LinearMap(E + E' - 2I);\n\njulia> Δ₁ = kron(D, J) + kron(J, D); # discrete 2D-Laplace operator, Kronecker sum\n\njulia> Δ₂ = sumkronsum(D, D);\n\njulia> Δ₃ = D^⊕(2);\n\njulia> Matrix(Δ₁) == Matrix(Δ₂) == Matrix(Δ₃)\ntrue\n\n[1]: Fernandes, P. and Plateau, B. and Stewart, W. J. \"Efficient Descriptor-Vector Multiplications in Stochastic Automata Networks\", Journal of the ACM, 45(3), 381–414, 1998.\n\n\n\n\n\n","category":"function"},{"location":"types/#BlockMap-and-BlockDiagonalMap","page":"Types and methods","title":"BlockMap and BlockDiagonalMap","text":"","category":"section"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"Types for representing block (diagonal) maps lazily.","category":"page"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"Base.hcat\nBase.vcat\nBase.hvcat\nBase.cat\nSparseArrays.blockdiag","category":"page"},{"location":"types/#Base.hcat","page":"Types and methods","title":"Base.hcat","text":"hcat(As::Union{LinearMap,UniformScaling,AbstractVecOrMatOrQ}...)::BlockMap\n\nConstruct a (lazy) representation of the horizontal concatenation of the arguments. All arguments are promoted to LinearMaps automatically.\n\nExamples\n\njulia> CS = LinearMap{Int}(cumsum, 3)::LinearMaps.FunctionMap;\n\njulia> L = [CS LinearMap(ones(Int, 3, 3))]::LinearMaps.BlockMap;\n\njulia> L * ones(Int, 6)\n3-element Array{Int64,1}:\n 4\n 5\n 6\n\n\n\n\n\n","category":"function"},{"location":"types/#Base.vcat","page":"Types and methods","title":"Base.vcat","text":"vcat(As::Union{LinearMap,UniformScaling,AbstractVecOrMatOrQ}...)::BlockMap\n\nConstruct a (lazy) representation of the vertical concatenation of the arguments. All arguments are promoted to LinearMaps automatically.\n\nExamples\n\njulia> CS = LinearMap{Int}(cumsum, 3)::LinearMaps.FunctionMap;\n\njulia> L = [CS; LinearMap(ones(Int, 3, 3))]::LinearMaps.BlockMap;\n\njulia> L * ones(Int, 3)\n6-element Array{Int64,1}:\n 1\n 2\n 3\n 3\n 3\n 3\n\n\n\n\n\n","category":"function"},{"location":"types/#Base.hvcat","page":"Types and methods","title":"Base.hvcat","text":"hvcat(rows::Tuple{Vararg{Int}}, As::Union{LinearMap,UniformScaling,AbstractVecOrMatOrQ}...)::BlockMap\n\nConstruct a (lazy) representation of the horizontal-vertical concatenation of the arguments. The first argument specifies the number of arguments to concatenate in each block row. All arguments are promoted to LinearMaps automatically.\n\nExamples\n\njulia> CS = LinearMap{Int}(cumsum, 3)::LinearMaps.FunctionMap;\n\njulia> L = [CS CS; CS CS]::LinearMaps.BlockMap;\n\njulia> L.rows\n(2, 2)\n\njulia> L * ones(Int, 6)\n6-element Array{Int64,1}:\n 2\n 4\n 6\n 2\n 4\n 6\n\n\n\n\n\n","category":"function"},{"location":"types/#Base.cat","page":"Types and methods","title":"Base.cat","text":"cat(As::Union{LinearMap,AbstractVecOrMatOrQ}...; dims=(1,2))::BlockDiagonalMap\n\nConstruct a (lazy) representation of the diagonal concatenation of the arguments. To avoid fallback to the generic Base.cat, there must be a LinearMap object among the first 8 arguments.\n\n\n\n\n\n","category":"function"},{"location":"types/#FillMap","page":"Types and methods","title":"FillMap","text":"","category":"section"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"Type for lazily representing constantly filled matrices.","category":"page"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"FillMap","category":"page"},{"location":"types/#LinearMaps.FillMap","page":"Types and methods","title":"LinearMaps.FillMap","text":"FillMap(λ, (m, n))::FillMap\nFillMap(λ, m, n)::FillMap\n\nConstruct a (lazy) representation of an operator whose matrix representation would be an m×n-matrix filled constantly with the value λ.\n\n\n\n\n\n","category":"type"},{"location":"types/#EmbeddedMap","page":"Types and methods","title":"EmbeddedMap","text":"","category":"section"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"Type for representing linear maps that are embedded in larger zero maps.","category":"page"},{"location":"types/#InverseMap","page":"Types and methods","title":"InverseMap","text":"","category":"section"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"Type for lazy inverse of another linear map.","category":"page"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"InverseMap","category":"page"},{"location":"types/#LinearMaps.InverseMap","page":"Types and methods","title":"LinearMaps.InverseMap","text":"InverseMap(A; solver = ldiv!)\n\nLazy inverse of A such that InverseMap(A) * x is the same as A \\ x. Letting an InverseMap act on a vector thus requires solving a linear system.\n\nA solver function can be passed with the solver keyword argument. The solver should be of the form f(y, A, x) where A is the wrapped map, x the right hand side, and y a preallocated output vector in which the result should be stored. The default solver is LinearAlgebra.ldiv!.\n\nNote that A must be compatible with the solver function. A can, for example, be a factorization of a matrix, or another LinearMap (in combination with an iterative solver such as conjugate gradient).\n\nExamples\n\njulia> using LinearMaps, LinearAlgebra\n\njulia> A = rand(2, 2); b = rand(2);\n\njulia> InverseMap(lu(A)) * b\n2-element Vector{Float64}:\n  1.0531895201271027\n -0.4718540250893251\n\njulia> A \\ b\n2-element Vector{Float64}:\n  1.0531895201271027\n -0.4718540250893251\n\n\n\n\n\n","category":"type"},{"location":"types/#KhatriRaoMap-and-FaceSplittingMap","page":"Types and methods","title":"KhatriRaoMap and FaceSplittingMap","text":"","category":"section"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"Types for lazy column-wise and row-wise Kronecker product, respectively, also referrerd to as Khatri-Rao and transposed Khatri-Rao (or face-splitting) product.","category":"page"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"khatrirao\nfacesplitting","category":"page"},{"location":"types/#LinearMaps.khatrirao","page":"Types and methods","title":"LinearMaps.khatrirao","text":"khatrirao(A::MapOrVecOrMat, B::MapOrVecOrMat) -> KhatriRaoMap\n\nConstruct a lazy representation of the Khatri-Rao (or column-wise Kronecker) product of two maps or arrays A and B. For the application to vectors, the tranpose action of A on vectors needs to be defined.\n\n\n\n\n\n","category":"function"},{"location":"types/#LinearMaps.facesplitting","page":"Types and methods","title":"LinearMaps.facesplitting","text":"facesplitting(A::AbstractMatrix, B::AbstractMatrix) -> FaceSplittingMap\n\nConstruct a lazy representation of the face-splitting (or row-wise Kronecker) product of two matrices A and B.\n\n\n\n\n\n","category":"function"},{"location":"types/#Methods","page":"Types and methods","title":"Methods","text":"","category":"section"},{"location":"types/#Multiplication-methods","page":"Types and methods","title":"Multiplication methods","text":"","category":"section"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"Base.:*(::LinearMap,::AbstractVector)\nBase.:*(::LinearMap,::AbstractMatrix)\nBase.:*(::AbstractMatrix,::LinearMap)\nLinearAlgebra.mul!(::AbstractVecOrMat,::LinearMap,::AbstractVector)\nLinearAlgebra.mul!(::AbstractVecOrMat,::LinearMap,::AbstractVector,::Number,::Number)\nLinearAlgebra.mul!(::AbstractMatrix,::AbstractMatrix,::LinearMap)\nLinearAlgebra.mul!(::AbstractMatrix,::AbstractMatrix,::LinearMap,::Number,::Number)\nLinearAlgebra.mul!(::AbstractVecOrMat,::LinearMap,::Number)\nLinearAlgebra.mul!(::AbstractMatrix,::LinearMap,::Number,::Number,::Number)\n*(::LinearAlgebra.AdjointAbsVec,::LinearMap)\n*(::LinearAlgebra.TransposeAbsVec,::LinearMap)","category":"page"},{"location":"types/#Base.:*-Tuple{LinearMap, AbstractVector}","page":"Types and methods","title":"Base.:*","text":"*(A::LinearMap, x::AbstractVector)::AbstractVector\n\nCompute the action of the linear map A on the vector x.\n\nExamples\n\njulia> A=LinearMap([1.0 2.0; 3.0 4.0]); x=[1.0, 1.0];\n\njulia> A*x\n2-element Array{Float64,1}:\n 3.0\n 7.0\n\njulia> A(x)\n2-element Array{Float64,1}:\n 3.0\n 7.0\n\n\n\n\n\n","category":"method"},{"location":"types/#Base.:*-Tuple{LinearMap, AbstractMatrix}","page":"Types and methods","title":"Base.:*","text":"*(A::LinearMap, X::AbstractMatrix)::CompositeMap\n\nReturn the CompositeMap A*LinearMap(X), interpreting the matrix X as a linear operator, rather than a collection of column vectors. To compute the action of A on each column of X, call Matrix(A*X) or use the in-place multiplication mul!(Y, A, X[, α, β]) with an appropriately sized, preallocated matrix Y.\n\nExamples\n\njulia> A=LinearMap([1.0 2.0; 3.0 4.0]); X=[1.0 1.0; 1.0 1.0];\n\njulia> A*X isa LinearMaps.CompositeMap\ntrue\n\n\n\n\n\n","category":"method"},{"location":"types/#Base.:*-Tuple{AbstractMatrix, LinearMap}","page":"Types and methods","title":"Base.:*","text":"*(X::AbstractMatrix, A::LinearMap)::CompositeMap\n\nReturn the CompositeMap LinearMap(X)*A, interpreting the matrix X as a linear operator. To compute the right-action of A on each row of X, call Matrix(X*A) or mul!(Y, X, A) for the in-place version.\n\nExamples\n\njulia> X=[1.0 1.0; 1.0 1.0]; A=LinearMap([1.0 2.0; 3.0 4.0]);\n\njulia> X*A isa LinearMaps.CompositeMap\ntrue\n\n\n\n\n\n","category":"method"},{"location":"types/#LinearAlgebra.mul!-Tuple{AbstractVecOrMat, LinearMap, AbstractVector}","page":"Types and methods","title":"LinearAlgebra.mul!","text":"mul!(Y::AbstractVecOrMat, A::LinearMap, B::AbstractVector) -> Y\nmul!(Y::AbstractMatrix, A::LinearMap, B::AbstractMatrix) -> Y\n\nCalculates the action of the linear map A on the vector or matrix B and stores the result in Y, overwriting the existing value of Y. Note that Y must not be aliased with either A or B.\n\nExamples\n\njulia> A=LinearMap([1.0 2.0; 3.0 4.0]); B=ones(2); Y = similar(B); mul!(Y, A, B);\n\njulia> Y\n2-element Array{Float64,1}:\n 3.0\n 7.0\n\njulia> A=LinearMap([1.0 2.0; 3.0 4.0]); B=ones(4,4); Y = similar(B); mul!(Y, A, B);\n\njulia> Y\n2×2 Array{Float64,2}:\n 3.0  3.0\n 7.0  7.0\n\n\n\n\n\n","category":"method"},{"location":"types/#LinearAlgebra.mul!-Tuple{AbstractVecOrMat, LinearMap, AbstractVector, Number, Number}","page":"Types and methods","title":"LinearAlgebra.mul!","text":"mul!(C::AbstractVecOrMat, A::LinearMap, B::AbstractVector, α, β) -> C\nmul!(C::AbstractMatrix, A::LinearMap, B::AbstractMatrix, α, β) -> C\n\nCombined inplace multiply-add A B α + C β. The result is stored in C by overwriting it. Note that C must not be aliased with either A or B.\n\nExamples\n\njulia> A=LinearMap([1.0 2.0; 3.0 4.0]); B=[1.0, 1.0]; C=[1.0, 3.0];\n\njulia> mul!(C, A, B, 100.0, 10.0) === C\ntrue\n\njulia> C\n2-element Array{Float64,1}:\n 310.0\n 730.0\n\njulia> A=LinearMap([1.0 2.0; 3.0 4.0]); B=[1.0 1.0; 1.0 1.0]; C=[1.0 2.0; 3.0 4.0];\n\njulia> mul!(C, A, B, 100.0, 10.0) === C\ntrue\n\njulia> C\n2×2 Array{Float64,2}:\n 310.0  320.0\n 730.0  740.0\n\n\n\n\n\n","category":"method"},{"location":"types/#LinearAlgebra.mul!-Tuple{AbstractMatrix, AbstractMatrix, LinearMap}","page":"Types and methods","title":"LinearAlgebra.mul!","text":"mul!(C::AbstractMatrix, A::AbstractMatrix, B::LinearMap) -> C\n\nCalculates the matrix representation of A*B and stores the result in C, overwriting the existing value of C. Note that C must not be aliased with either A or B. The computation C = A*B is performed via C' = B'A'.\n\nExamples\n\njulia> A=[1.0 1.0; 1.0 1.0]; B=LinearMap([1.0 2.0; 3.0 4.0]); C = similar(A); mul!(C, A, B);\n\njulia> C\n2×2 Array{Float64,2}:\n 4.0  6.0\n 4.0  6.0\n\n\n\n\n\n","category":"method"},{"location":"types/#LinearAlgebra.mul!-Tuple{AbstractMatrix, AbstractMatrix, LinearMap, Number, Number}","page":"Types and methods","title":"LinearAlgebra.mul!","text":"mul!(C::AbstractMatrix, A::AbstractMatrix, B::LinearMap, α, β) -> C\n\nCombined inplace multiply-add A B α + C β. The result is stored in C by overwriting it. Note that C must not be aliased with either A or B.\n\nExamples\n\njulia> A=[1.0 1.0; 1.0 1.0]; B=LinearMap([1.0 2.0; 3.0 4.0]); C = copy(A);\n\njulia> mul!(C, A, B, 1, 1)\n2×2 Matrix{Float64}:\n 5.0  7.0\n 5.0  7.0\n\n\n\n\n\n","category":"method"},{"location":"types/#LinearAlgebra.mul!-Tuple{AbstractVecOrMat, LinearMap, Number}","page":"Types and methods","title":"LinearAlgebra.mul!","text":"mul!(Y::AbstractMatrix, A::LinearMap, b::Number) -> Y\n\nScales the matrix representation of the linear map A by b and stores the result in Y, overwriting the existing value of Y.\n\nExamples\n\njulia> A = LinearMap{Int}(cumsum, 3); b = 2; Y = Matrix{Int}(undef, (3,3));\n\njulia> mul!(Y, A, b)\n3×3 Matrix{Int64}:\n 2  0  0\n 2  2  0\n 2  2  2\n\n\n\n\n\n","category":"method"},{"location":"types/#LinearAlgebra.mul!-Tuple{AbstractMatrix, LinearMap, Number, Number, Number}","page":"Types and methods","title":"LinearAlgebra.mul!","text":"mul!(Y::AbstractMatrix, A::LinearMap, b::Number, α::Number, β::Number) -> Y\n\nScales the matrix representation of the linear map A by b*α, adds the result to Y*β and stores the final result in Y, overwriting the existing value of Y.\n\nExamples\n\njulia> A = LinearMap{Int}(cumsum, 3); b = 2; Y = ones(Int, (3,3));\n\njulia> mul!(Y, A, b, 2, 1)\n3×3 Matrix{Int64}:\n 5  1  1\n 5  5  1\n 5  5  5\n\n\n\n\n\n","category":"method"},{"location":"types/#Base.:*-Tuple{Adjoint{T, <:AbstractVector} where T, LinearMap}","page":"Types and methods","title":"Base.:*","text":"*(x::LinearAlgebra.AdjointAbsVec, A::LinearMap)::AdjointAbsVec\n\nCompute the right-action of the linear map A on the adjoint vector x and return an adjoint vector.\n\nExamples\n\njulia> A=LinearMap([1.0 2.0; 3.0 4.0]); x=[1.0, 1.0]; x'A\n1×2 Adjoint{Float64,Array{Float64,1}}:\n 4.0  6.0\n\n\n\n\n\n","category":"method"},{"location":"types/#Base.:*-Tuple{Transpose{T, <:AbstractVector} where T, LinearMap}","page":"Types and methods","title":"Base.:*","text":"*(x::LinearAlgebra.TransposeAbsVec, A::LinearMap)::TransposeAbsVec\n\nCompute the right-action of the linear map A on the transpose vector x and return a transpose vector.\n\nExamples\n\njulia> A=LinearMap([1.0 2.0; 3.0 4.0]); x=[1.0, 1.0]; transpose(x)*A\n1×2 Transpose{Float64,Array{Float64,1}}:\n 4.0  6.0\n\n\n\n\n\n","category":"method"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"Applying the adjoint or transpose of A (if defined) to x works exactly as in the usual matrix case: transpose(A) * x and mul!(y, A', x), for instance.","category":"page"},{"location":"types/#Conversion-methods","page":"Types and methods","title":"Conversion methods","text":"","category":"section"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"Array, Matrix and associated convert methods\nCreate a dense matrix representation of the LinearMap object, by multiplying it with the successive basis vectors. This is mostly for testing purposes or if you want to have the explicit matrix representation of a linear map for which you only have a function definition (e.g. to be able to use its transpose or adjoint). This way, one may conveniently make A act on the columns of a matrix X, instead of interpreting A * X as a composed linear map: Matrix(A * X). For generic code, that is supposed to handle both A::AbstractMatrix and A::LinearMap, it is recommended to use convert(Matrix, A*X).\nconvert(Abstract[Matrix/Array], A::LinearMap)\nCreate an AbstractMatrix representation of the LinearMap. This falls back to Matrix(A), but avoids explicit construction in case the LinearMap object is matrix-based.\nSparseArrays.sparse(A::LinearMap) and convert(SparseMatrixCSC, A::LinearMap)\nCreate a sparse matrix representation of the LinearMap object, by multiplying it with the successive basis vectors. This is mostly for testing purposes or if you want to have the explicit sparse matrix representation of a linear map for which you only have a function definition (e.g. to be able to use its transpose or adjoint).","category":"page"},{"location":"types/#Slicing-methods","page":"Types and methods","title":"Slicing methods","text":"","category":"section"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"Complete slicing, i.e., A[:,j], A[:,J], A[i,:], A[I,:] and A[:,:] for i, j Integer and I, J AbstractVector{<:Integer} is generically available for any A::LinearMap subtype via application of A (or A' for (predominantly) horizontal slicing) to standard unit vectors of appropriate length. By complete slicing we refer two-dimensional Cartesian indexing where at least one of the \"indices\" is a colon. This is facilitated by overloads of Base.getindex. Partial slicing à la A[I,J] and scalar or linear indexing are not supported.","category":"page"}]
}
