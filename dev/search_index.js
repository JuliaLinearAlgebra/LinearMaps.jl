var documenterSearchIndex = {"docs":
[{"location":"history/#Version-history","page":"Version history","title":"Version history","text":"","category":"section"},{"location":"history/#What's-new-in-v3.2","page":"Version history","title":"What's new in v3.2","text":"","category":"section"},{"location":"history/","page":"Version history","title":"Version history","text":"In-place left-multiplication mul!(Y, X, A::LinearMap) is now allowed for X::AbstractMatrix and implemented via the adjoint equation Y' = A'X'.","category":"page"},{"location":"history/#What's-new-in-v3.1","page":"Version history","title":"What's new in v3.1","text":"","category":"section"},{"location":"history/","page":"Version history","title":"Version history","text":"In Julia v1.3 and above, LinearMap-typed objects are callable on AbstractVectors: For L::LinearMap and x::AbstractVector, L(x) = L*x.","category":"page"},{"location":"history/#What's-new-in-v3.0","page":"Version history","title":"What's new in v3.0","text":"","category":"section"},{"location":"history/","page":"Version history","title":"Version history","text":"BREAKING change: Internally, any dependence on former A*_mul_B! methods is abandonned. For custom LinearMap subtypes, there are now two options:\nIn case your type is invariant under adjoint/transposition (i.e., adjoint(L::MyLinearMap)::MyLinearMap similar to, for instance, LinearCombinations or CompositeMaps, At_mul_B! and Ac_mul_B! do not require any replacement! Rather, multiplication by L' is, in this case, handled by mul!(y, L::MyLinearMap, x[, α, β]).\nOtherwise, you will need to define mul! methods with the signature mul!(y, L::TransposeMap{<:Any,MyLinearMap}, x[, α, β]) and mul!(y, L::AdjointMap{<:Any,MyLinearMap}, x[, α, β]).\nLeft multiplying by a transpose or adjoint vector (e.g., y'*A) produces a transpose or adjoint vector output, rather than a composite LinearMap.\nBlock concatenation now handles matrices and vectors directly by internal promotion to LinearMaps. For [h/v/hc]cat it suffices to have a LinearMap object anywhere in the list of arguments. For the block-diagonal concatenation via SparseArrays.blockdiag, a LinearMap object has to appear among the first 8 arguments. This restriction, however, does not apply to block-diagonal concatenation via Base.cat(As...; dims=(1,2)).\nIntroduction of more expressive and visually appealing show methods, replacing the fallback to the generic show.","category":"page"},{"location":"history/#What's-new-in-v2.7","page":"Version history","title":"What's new in v2.7","text":"","category":"section"},{"location":"history/","page":"Version history","title":"Version history","text":"Potential reduction of memory allocations in multiplication of LinearCombinations, BlockMaps, and real- or complex-scaled LinearMaps. For the latter, a new internal type ScaledMap has been introduced.\nMultiplication code for CompositeMaps has been refactored to facilitate to provide memory for storage of intermediate results by directly calling helper functions.","category":"page"},{"location":"history/#What's-new-in-v2.6","page":"Version history","title":"What's new in v2.6","text":"","category":"section"},{"location":"history/","page":"Version history","title":"Version history","text":"New feature: \"lazy\" Kronecker product, Kronecker sums, and powers thereof for LinearMaps. AbstractMatrix objects are promoted to LinearMaps if one of the first 8 Kronecker factors is a LinearMap object.\nCompatibility with the generic multiply-and-add interface (a.k.a. 5-arg mul!) introduced in julia v1.3","category":"page"},{"location":"history/#What's-new-in-v2.5","page":"Version history","title":"What's new in v2.5","text":"","category":"section"},{"location":"history/","page":"Version history","title":"Version history","text":"New feature: concatenation of LinearMaps objects with UniformScalings, consistent with (h-, v-, and hc-)concatenation of matrices. Note, matrices A must be wrapped as LinearMap(A), UniformScalings are promoted to LinearMaps automatically.","category":"page"},{"location":"history/#What's-new-in-v2.4","page":"Version history","title":"What's new in v2.4","text":"","category":"section"},{"location":"history/","page":"Version history","title":"Version history","text":"Support restricted to Julia v1.0+.","category":"page"},{"location":"history/#What's-new-in-v2.3","page":"Version history","title":"What's new in v2.3","text":"","category":"section"},{"location":"history/","page":"Version history","title":"Version history","text":"Fully Julia v0.7/v1.0/v1.1 compatible.\nFull support of noncommutative number types such as quaternions.","category":"page"},{"location":"history/#What's-new-in-v2.2","page":"Version history","title":"What's new in v2.2","text":"","category":"section"},{"location":"history/","page":"Version history","title":"Version history","text":"Fully Julia v0.7/v1.0 compatible.\nA convert(SparseMatrixCSC, A::LinearMap) function, that calls the sparse matrix generating function.","category":"page"},{"location":"history/#What's-new-in-v2.1","page":"Version history","title":"What's new in v2.1","text":"","category":"section"},{"location":"history/","page":"Version history","title":"Version history","text":"Fully Julia v0.7 compatible; dropped compatibility for previous versions of Julia from LinearMaps.jl v2.0.0 on.\nA 5-argument version for mul!(y, A::LinearMap, x, α=1, β=0), which computes y := α * A * x + β * y and implements the usual 3-argument mul!(y, A, x) for the default α and β.\nSynonymous convert(Matrix, A::LinearMap) and convert(Array, A::LinearMap) functions, that call the Matrix constructor and return the matrix representation of A.\nMultiplication with matrices, interpreted as a block row vector of vectors:\nmul!(Y::AbstractArray, A::LinearMap, X::AbstractArray, α=1, β=0): applies A to each column of X and stores the result in-place in the corresponding column of Y;\nfor the out-of-place multiplication, the approach is to compute convert(Matrix, A * X); this is equivalent to applying A to each column of X. In generic code which handles both A::AbstractMatrix and A::LinearMap, the additional call to convert is a noop when A is a matrix.\nFull compatibility with Arpack.jl's eigs and svds; previously only eigs was working. For more, nicely collaborating packages see the Example section.","category":"page"},{"location":"related/#Related-open-source-packages","page":"Related packages","title":"Related open-source packages","text":"","category":"section"},{"location":"related/","page":"Related packages","title":"Related packages","text":"The following open-source packages provide similar or even extended functionality as LinearMaps.jl.","category":"page"},{"location":"related/","page":"Related packages","title":"Related packages","text":"Spot: A linear-operator toolbox for Matlab, which seems to have heavily inspired the Julia package LinearOperators.jl and the Python package PyLops\nfastmat: fast linear transforms in Python\nFunctionOperators.jl and LinearMapsAA.jl also support mappings between Arrays, inspired by the fatrix object type in the Matlab version of the Michigan Image Reconstruction Toolbox (MIRT).","category":"page"},{"location":"related/","page":"Related packages","title":"Related packages","text":"As for lazy array manipulation (like addition, composition, Kronecker products and concatenation), there exist further related packages in the Julia ecosystem:","category":"page"},{"location":"related/","page":"Related packages","title":"Related packages","text":"LazyArrays.jl\nBlockArrays.jl\nBlockDiagonals.jl\nKronecker.jl\nFillArrays.jl","category":"page"},{"location":"related/","page":"Related packages","title":"Related packages","text":"Since these packages provide types that are subtypes of Julia Base's AbstractMatrix type, objects of those types can be wrapped by a LinearMap and freely mixed with, for instance, function-based linear maps. The same applies to custom matrix types as provided, for instance, by packages maintained by the JuliaArrays github organization. For any CustomMatrix{T} <: AbstractMatrix{T} type, you only need to provide a mul!(::AbstractVecOrMat, ::CustomMatrix, ::AbstractVector[, ::Number, ::Number]) method for seamless integration with LinearMaps.jl.","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"EditURL = \"https://github.com/Jutho/LinearMaps.jl/blob/master/docs/src/custom.jl\"","category":"page"},{"location":"generated/custom/#Defining-custom-LinearMap-types","page":"Custom maps","title":"Defining custom LinearMap types","text":"","category":"section"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"In this section, we want to demonstrate on a simple, actually built-in, linear map type how to define custom LinearMap subtypes. First of all, LinearMap{T} is an extendable abstract type, where T denotes the eltype.","category":"page"},{"location":"generated/custom/#Basics","page":"Custom maps","title":"Basics","text":"","category":"section"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"As an example, we want to define a map type whose objects correspond to lazy analogues of filled matrices. Naturally, we need to store the filled value λ and the size of the linear map.","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"using LinearMaps, LinearAlgebra\n\nstruct MyFillMap{T} <: LinearMaps.LinearMap{T}\n    λ::T\n    size::Dims{2}\n    function MyFillMap(λ::T, dims::Dims{2}) where {T}\n        all(≥(0), dims) || throw(ArgumentError(\"dims of MyFillMap must be non-negative\"))\n        promote_type(T, typeof(λ)) == T || throw(InexactError())\n        return new{T}(λ, dims)\n    end\nend","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"By default, for any A::MyFillMap{T}, eltype(A) returns T. Upon application to a vector x and/or interaction with other LinearMap objects, we need to check consistent sizes.","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"Base.size(A::MyFillMap) = A.size","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"By a couple of defaults provided for all subtypes of LinearMap, we only need to define a LinearAlgebra.mul! method to have minimal, operational type.","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"function LinearAlgebra.mul!(y::AbstractVecOrMat, A::MyFillMap, x::AbstractVector)\n    LinearMaps.check_dim_mul(y, A, x)\n    return fill!(y, iszero(A.λ) ? zero(eltype(y)) : A.λ*sum(x))\nend","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"Again, due to generic fallbacks the following now \"just work\":","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"out-of-place multiplication A*x,\nin-place multiplication with vectors mul!(y, A, x),\nin-place multiply-and-add with vectors mul!(y, A, x, α, β),\nin-place multiplication and multiply-and-add with matrices mul!(Y, A, X, α, β),\nconversion to a (sparse) matrix Matrix(A) and sparse(A).","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"A = MyFillMap(5.0, (3, 3)); x = ones(3); sum(x)","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"A * x","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"mul!(zeros(3), A, x)","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"mul!(ones(3), A, x, 2, 2)","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"mul!(ones(3,3), A, reshape(collect(1:9), 3, 3), 2, 2)","category":"page"},{"location":"generated/custom/#Multiply-and-add-and-the-MulStyle-trait","page":"Custom maps","title":"Multiply-and-add and the MulStyle trait","text":"","category":"section"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"While the above function calls work out of the box due to generic fallbacks, the latter may be suboptimally implemented for your custom map type. Let's see some benchmarks.","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"using BenchmarkTools\n\n@benchmark mul!($(zeros(3)), $A, $x)","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"@benchmark mul!($(zeros(3)), $A, $x, $(rand()), $(rand()))","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"The second benchmark indicates the allocation of an intermediate vector z which stores the result of A*x before it gets scaled and added to (the scaled) y = zeros(3). For that reason, it is beneficial to provide a custom \"5-arg mul!\" if you can avoid the allocation of an intermediate vector. To indicate that there exists an allocation-free implementation, you should set the MulStyle trait, whose default is ThreeArg().","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"LinearMaps.MulStyle(A::MyFillMap) = FiveArg()\n\nfunction LinearAlgebra.mul!(\n    y::AbstractVecOrMat,\n    A::MyFillMap,\n    x::AbstractVector,\n    α::Number,\n    β::Number\n)\n    if iszero(α)\n        !isone(β) && rmul!(y, β)\n        return y\n    else\n        temp = A.λ * sum(x) * α\n        if iszero(β)\n            y .= temp\n        elseif isone(β)\n            y .+= temp\n        else\n            y .= y .* β .+ temp\n        end\n    end\n    return y\nend","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"With this function at hand, let's redo the benchmark.","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"@benchmark mul!($(zeros(3)), $A, $x, $(rand()), $(rand()))","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"There you go, the allocation is gone and the computation time is significantly reduced.","category":"page"},{"location":"generated/custom/#Adjoints-and-transposes","page":"Custom maps","title":"Adjoints and transposes","text":"","category":"section"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"Generically, taking the transpose (or the adjoint) of a (real, resp.) map wraps the linear map by a TransposeMap, taking the adjoint of a complex map wraps it by an AdjointMap.","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"typeof(A')","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"Not surprisingly, without further definitions, multiplying A' by x yields an error.","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"try A'x catch e println(e) end","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"If the operator is symmetric or Hermitian, the transpose and the adjoint, respectively, of the linear map A is given by A itself. So let's define corresponding checks.","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"LinearAlgebra.issymmetric(A::MyFillMap) = A.size[1] == A.size[2]\nLinearAlgebra.ishermitian(A::MyFillMap) = isreal(A.λ) && A.size[1] == A.size[2]\nLinearAlgebra.isposdef(A::MyFillMap) = (size(A, 1) == size(A, 2) == 1 && isposdef(A.λ))\nBase.:(==)(A::MyFillMap, B::MyFillMap) = A.λ == B.λ && A.size == B.size","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"These are used, for instance, in checking symmetry or positive definiteness of higher-order LinearMaps, like products or linear combinations of linear maps, or signal to iterative eigenproblem solvers that real eigenvalues are to be computed. Without these definitions, the first three functions would return false (by default), and the last one would fall back to ===.","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"With this at hand, we note that A above is symmetric, and we can compute","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"transpose(A)*x","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"This, however, does not work for nonsquare maps","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"try MyFillMap(5.0, (3, 4))' * ones(3) catch e println(e) end","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"which require explicit adjoint/transpose handling, for which there exist two distinct paths.","category":"page"},{"location":"generated/custom/#Path-1:-Generic,-non-invariant-LinearMap-subtypes","page":"Custom maps","title":"Path 1: Generic, non-invariant LinearMap subtypes","text":"","category":"section"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"The first option is to write LinearAlgebra.mul! methods for the corresponding wrapped map types; for instance,","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"function LinearAlgebra.mul!(\n    y::AbstractVecOrMat,\n    transA::LinearMaps.TransposeMap{<:Any,<:MyFillMap},\n    x::AbstractVector\n)\n    LinearMaps.check_dim_mul(y, transA, x)\n    λ = transA.lmap.λ\n    return fill!(y, iszero(λ) ? zero(eltype(y)) : transpose(λ)*sum(x))\nend","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"If you have set the MulStyle trait to FiveArg(), you should provide a corresponding 5-arg mul! method for LinearMaps.TransposeMap{<:Any,<:MyFillMap} and LinearMaps.AdjointMap{<:Any,<:MyFillMap}.","category":"page"},{"location":"generated/custom/#Path-2:-Invariant-LinearMap-subtypes","page":"Custom maps","title":"Path 2: Invariant LinearMap subtypes","text":"","category":"section"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"The seconnd option is when your class of linear maps that are modelled by your custom LinearMap subtype are invariant under taking adjoints and transposes.","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"LinearAlgebra.adjoint(A::MyFillMap) = MyFillMap(adjoint(A.λ), reverse(A.size))\nLinearAlgebra.transpose(A::MyFillMap) = MyFillMap(transpose(A.λ), reverse(A.size))","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"With such invariant definitions, i.e., the adjoint/transpose of a MyFillMap is again a MyFillMap, no further method definitions are required, and the entire functionality listed above just works for adjoints/transposes of your custom map type.","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"mul!(ones(3), A', x, 2, 2)","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"MyFillMap(5.0, (3, 4))' * ones(3)","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"Now that we have defined the action of adjoints/transposes, the following right action on vectors is automatically defined:","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"ones(3)' * MyFillMap(5.0, (3, 4))","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"and transpose(x) * A correspondingly, as well as in-place multiplication","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"mul!(similar(x)', x', A)","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"and mul!(transpose(y), transpose(x), A).","category":"page"},{"location":"generated/custom/#Application-to-matrices","page":"Custom maps","title":"Application to matrices","text":"","category":"section"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"By default, applying a LinearMap A to a matrix X via A*X does not apply A to each column of X viewed as a vector, but interprets X as a linear map, wraps it as such and returns (A*X)::CompositeMap. Calling the in-place multiplication function mul!(Y, A, X) for matrices, however, does compute the columnwise action of A on X and stores the result in Y. In case there is a more efficient implementation for the matrix application, you can provide mul! methods with signature mul!(Y::AbstractMatrix, A::MyFillMap, X::AbstractMatrix), and, depending on the chosen path to handle adjoints/transposes, corresponding methods for wrapped maps of type AdjointMap or TransposeMap, plus potentially corresponding 5-arg mul! methods. This may seem like a lot of methods to be implemented, but note that adding such methods is only necessary/recommended for performance.","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"","category":"page"},{"location":"generated/custom/","page":"Custom maps","title":"Custom maps","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#LinearMaps.jl","page":"Home","title":"LinearMaps.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package for defining and working with linear maps, also known as linear transformations or linear operators acting on vectors. The only requirement for a LinearMap is that it can act on a vector (by multiplication) efficiently.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"LinearMaps.jl is a registered package and can be installed via","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add LinearMaps","category":"page"},{"location":"","page":"Home","title":"Home","text":"in package mode, to be entered by typing ] in the Julia REPL.","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Let","category":"page"},{"location":"","page":"Home","title":"Home","text":"A = LinearMap(rand(10, 10))\nB = LinearMap(cumsum, reverse∘cumsum∘reverse, 10)","category":"page"},{"location":"","page":"Home","title":"Home","text":"be a matrix- and function-based linear map, respectively. Then the following code just works, indistinguishably from the case when A and B are both AbstractMatrix-typed objects.","category":"page"},{"location":"","page":"Home","title":"Home","text":"3.0A + 2B\nA + I\nA*B'\n[A B; B A]\nkron(A, B)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The LinearMap type and corresponding methods combine well with the following packages:","category":"page"},{"location":"","page":"Home","title":"Home","text":"ArnoldiMethods.jl\nArpack.jl: iterative eigensolver eigs and SVD svds;\nIterativeSolvers.jl: iterative solvers, eigensolvers, and SVD;\nKrylovKit.jl: Krylov-based algorithms for linear problems, singular value and eigenvalue problems\nTSVD.jl: truncated SVD tsvd.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using LinearMaps\nimport Arpack, IterativeSolvers, KrylovKit, TSVD, ArnoldiMethod\n\n# Example 1, 1-dimensional Laplacian with periodic boundary conditions\nfunction leftdiff!(y::AbstractVector, x::AbstractVector) # left difference assuming periodic boundary conditions\n    N = length(x)\n    length(y) == N || throw(DimensionMismatch())\n    @inbounds for i=1:N\n        y[i] = x[i] - x[mod1(i-1, N)]\n    end\n    return y\nend\n\nfunction mrightdiff!(y::AbstractVector, x::AbstractVector) # minus right difference\n    N = length(x)\n    length(y) == N || throw(DimensionMismatch())\n    @inbounds for i=1:N\n        y[i] = x[i] - x[mod1(i+1, N)]\n    end\n    return y\nend\n\nD = LinearMap(leftdiff!, mrightdiff!, 100; ismutating=true) # by default has eltype(D) = Float64\n\nArpack.eigs(D'D; nev=3, which=:SR) # note that D'D is recognized as symmetric => real eigenfact\nArpack.svds(D; nsv=3)\n\nArnoldiMethod.partialschur(D'D; nev=3, which=ArnoldiMethod.SR())\n\nKrylovKit.eigsolve(D'D, 100, 3, :SR)\n\nΣ, L = IterativeSolvers.svdl(D; nsv=3)\n\nTSVD.tsvd(D, 3)\n\n# Example 2, 3 smallest eigenvalues of 1-dimensional Laplacian\nA = LinearMap(100; issymmetric=true, ismutating=true) do C, B\n    C[1] = -2B[1] + B[2]\n    for i in 2:length(B)-1\n        C[i] = B[i-1] - 2B[i] + B[i+1]\n    end\n    C[end] = B[end-1] - 2B[end]\n    return C\nend\n\nArpack.eigs(-A; nev=3, which=:SR)\n\nArnoldiMethod.partialschur(-A; nev=3, which=ArnoldiMethod.SR())\n\nKrylovKit.eigsolve(-A, size(A, 1), 3, :SR)\n\n# Example 3, 2-dimensional Laplacian\nΔ = kronsum(A, A)\n\nArpack.eigs(Δ; nev=3, which=:LR)\nArnoldiMethod.partialeigen(ArnoldiMethod.partialschur(Δ; nev=3, which=ArnoldiMethod.LR())[1])\nKrylovKit.eigsolve(x -> Δ*x, size(Δ, 1), 3, :LR)","category":"page"},{"location":"","page":"Home","title":"Home","text":"In Julia v1.3 and above, the last line can be simplified to","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia KrylovKit.eigsolve(Δ, size(Δ, 1), 3, :LR)`","category":"page"},{"location":"","page":"Home","title":"Home","text":"leveraging the fact that objects of type L <: LinearMap are callable.","category":"page"},{"location":"#Philosophy","page":"Home","title":"Philosophy","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Several iterative linear algebra methods such as linear solvers or eigensolvers only require an efficient evaluation of the matrix-vector product, where the concept of a matrix can be formalized / generalized to a linear map (or linear operator in the special case of a square matrix).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The LinearMaps package provides the following functionality:","category":"page"},{"location":"","page":"Home","title":"Home","text":"A LinearMap type that shares with the AbstractMatrix type that it responds to the functions size, eltype, isreal, issymmetric, ishermitian and isposdef, transpose and adjoint and multiplication with a vector using both * or the in-place version mul!. Linear algebra functions that use duck-typing for their arguments can handle LinearMap objects similar to AbstractMatrix objects, provided that they can be written using the above methods. Unlike AbstractMatrix types, LinearMap objects cannot be indexed, neither using getindex or setindex!.\nA single function LinearMap that acts as a general purpose constructor (though it is only an abstract type) and allows to construct linear map objects from functions, or to wrap objects of type AbstractMatrix or LinearMap. The latter functionality is useful to (re)define the properties (isreal, issymmetric, ishermitian, isposdef) of the existing matrix or linear map.\nA framework for combining objects of type LinearMap and of type AbstractMatrix using linear combinations, transposition, composition, concatenation and Kronecker product/sums, where the linear map resulting from these operations is never explicitly evaluated but only its matrix-vector product is defined (i.e. lazy evaluation). The matrix-vector product is written to minimize memory allocation by using a minimal number of temporary vectors. There is full support for the in-place version mul!, which should be preferred for higher efficiency in critical algorithms. In addition, it tries to recognize the properties of combinations of linear maps. In particular, compositions such as A'*A for arbitrary A or even A'*B*C*B'*A with arbitrary A and B and positive definite C are recognized as being positive definite and hermitian. In case a certain property of the resulting LinearMap object is not correctly inferred, the LinearMap method can be called to redefine the properties.","category":"page"},{"location":"types/#Types-and-methods","page":"Types and methods","title":"Types and methods","text":"","category":"section"},{"location":"types/#Types-and-their-constructors","page":"Types and methods","title":"Types and their constructors","text":"","category":"section"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"None of the types below need to be constructed directly; they arise from performing operations between LinearMap objects or by calling the LinearMap constructor described next.","category":"page"},{"location":"types/#LinearMap","page":"Types and methods","title":"LinearMap","text":"","category":"section"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"Abstract supertype","category":"page"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"LinearMaps.LinearMap","category":"page"},{"location":"types/#LinearMaps.LinearMap","page":"Types and methods","title":"LinearMaps.LinearMap","text":"LinearMap(A::LinearMap; kwargs...)::WrappedMap\nLinearMap(A::AbstractMatrix; kwargs...)::WrappedMap\nLinearMap(J::UniformScaling, M::Int)::UniformScalingMap\nLinearMap{T=Float64}(f, [fc,], M::Int, N::Int = M; kwargs...)::FunctionMap\n\nConstruct a linear map object, either from an existing LinearMap or AbstractMatrix A, with the purpose of redefining its properties via the keyword arguments kwargs; a UniformScaling object J with specified (square) dimension M; from a Number object to lazily represent filled matrices; or from a function or callable object f. In the latter case, one also needs to specify the size of the equivalent matrix representation (M, N), i.e., for functions f acting on length N vectors and producing length M vectors (with default value N=M). Preferably, also the eltype T of the corresponding matrix representation needs to be specified, i.e. whether the action of f on a vector will be similar to, e.g., multiplying by numbers of type T. If not specified, the devault value T=Float64 will be assumed. Optionally, a corresponding function fc can be specified that implements the adjoint (=transpose in the real case) of f.\n\nThe keyword arguments and their default values for the function-based constructor are:\n\nissymmetric::Bool = false : whether A or f acts as a symmetric matrix\nishermitian::Bool = issymmetric & T<:Real : whether A or f acts as a Hermitian   matrix\nisposdef::Bool = false : whether A or f acts as a positive definite matrix.\n\nFor existing linear maps or matrices A, the default values will be taken by calling issymmetric, ishermitian and isposdef on the existing object A.\n\nFor the function-based constructor, there is one more keyword argument:\n\nismutating::Bool : flags whether the function acts as a mutating matrix multiplication   f(y,x) where the result vector y is the first argument (in case of true),   or as a normal matrix multiplication that is called as y=f(x) (in case of false).   The default value is guessed by looking at the number of arguments of the first   occurrence of f in the method table.\n\n\n\n\n\n","category":"type"},{"location":"types/#FunctionMap","page":"Types and methods","title":"FunctionMap","text":"","category":"section"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"Type for wrapping an arbitrary function that is supposed to implement the matrix-vector product as a LinearMap; see above.","category":"page"},{"location":"types/#WrappedMap","page":"Types and methods","title":"WrappedMap","text":"","category":"section"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"Type for wrapping an AbstractMatrix or LinearMap and to possible redefine the properties isreal, issymmetric, ishermitian and isposdef. An AbstractMatrix will automatically be converted to a WrappedMap when it is combined with other LinearMap objects via linear combination or composition (multiplication). Note that WrappedMap(mat1)*WrappedMap(mat2) will never evaluate mat1*mat2, since this is more costly than evaluating mat1*(mat2*x) and the latter is the only operation that needs to be performed by LinearMap objects anyway. While the cost of matrix addition is comparable to matrix-vector multiplication, this too is not performed explicitly since this would require new storage of the same amount as of the original matrices.","category":"page"},{"location":"types/#ScaledMap","page":"Types and methods","title":"ScaledMap","text":"","category":"section"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"Type for representing a scalar multiple of any LinearMap type. A ScaledMap will be automatically constructed if real or complex LinearMap objects are multiplied by real or complex scalars from the left or from the right.","category":"page"},{"location":"types/#UniformScalingMap","page":"Types and methods","title":"UniformScalingMap","text":"","category":"section"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"Type for representing a scalar multiple of the identity map (a.k.a. uniform scaling) of a certain size M=N, obtained simply as LinearMap(λI, M), where I is the LinearAlgebra.UniformScaling object. The type T of the resulting LinearMap object is inferred from the type of λ. A UniformScalingMap of the correct size will be automatically constructed if LinearMap objects are multiplied by scalars from the left or from the right (respecting the order of multiplication), if the scalar λ is either real or complex.","category":"page"},{"location":"types/#LinearCombination,-CompositeMap,-TransposeMap-and-AdjointMap","page":"Types and methods","title":"LinearCombination, CompositeMap, TransposeMap and AdjointMap","text":"","category":"section"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"Used to add/multiply/transpose/adjoint LinearMap objects lazily, don't need to be constructed explicitly.","category":"page"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"+(::LinearMap,::LinearMap)\n*(::LinearMap,::LinearMap)\nLinearAlgebra.transpose(::LinearMap)\nLinearAlgebra.adjoint(::LinearMap)","category":"page"},{"location":"types/#Base.:+-Tuple{LinearMap,LinearMap}","page":"Types and methods","title":"Base.:+","text":"+(A::LinearMap, B::LinearMap)::LinearCombination\n\nConstruct a (lazy) representation of the sum/linear combination of the two operators. Sums of LinearMap/LinearCombination objects and LinearMap/LinearCombination objects are reduced to a single LinearCombination. In sums of LinearMaps and AbstractMatrix/UniformScaling objects, the latter get promoted to LinearMaps automatically.\n\nExamples\n\njulia> CS = LinearMap{Int}(cumsum, 3)::LinearMaps.FunctionMap;\n\njulia> LinearMap(ones(Int, 3, 3)) + CS + I + rand(3, 3);\n\n\n\n\n\n","category":"method"},{"location":"types/#Base.:*-Tuple{LinearMap,LinearMap}","page":"Types and methods","title":"Base.:*","text":"*(A::LinearMap, B::LinearMap)::CompositeMap\n\nConstruct a (lazy) representation of the product of the two operators. Products of LinearMap/CompositeMap objects and LinearMap/CompositeMap objects are reduced to a single CompositeMap. In products of LinearMaps and AbstractMatrix/UniformScaling objects, the latter get promoted to LinearMaps automatically.\n\nExamples\n\njulia> CS = LinearMap{Int}(cumsum, 3)::LinearMaps.FunctionMap;\n\njulia> LinearMap(ones(Int, 3, 3)) * CS * I * rand(3, 3);\n\n\n\n\n\n","category":"method"},{"location":"types/#Base.transpose-Tuple{LinearMap}","page":"Types and methods","title":"Base.transpose","text":"transpose(A::LinearMap)\n\nConstruct a lazy representation of the transpose of A. This can be either a TransposeMap wrapper of A, or a suitably redefined instance of the same type as A. For instance, for a linear combination of linear maps A + B, the transpose is given by A^ + B^, i.e., another linear combination of linear maps.\n\n\n\n\n\n","category":"method"},{"location":"types/#Base.adjoint-Tuple{LinearMap}","page":"Types and methods","title":"Base.adjoint","text":"adjoint(A::LinearMap)\n\nConstruct a lazy representation of the adjoint of A. This can be either a AdjointMap wrapper of A, or a suitably redefined instance of the same type as A. For instance, for a linear combination of linear maps A + B, the adjoint is given by A^* + B^*, i.e., another linear combination of linear maps.\n\n\n\n\n\n","category":"method"},{"location":"types/#KroneckerMap-and-KroneckerSumMap","page":"Types and methods","title":"KroneckerMap and KroneckerSumMap","text":"","category":"section"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"Types for representing Kronecker products and Kronecker sums, resp., lazily.","category":"page"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"Base.kron(::LinearMap,::LinearMap)\nLinearMaps.:⊗\nkronsum\nLinearMaps.:⊕","category":"page"},{"location":"types/#Base.kron-Tuple{LinearMap,LinearMap}","page":"Types and methods","title":"Base.kron","text":"kron(A::LinearMap, B::LinearMap)::KroneckerMap\nkron(A, B, Cs...)::KroneckerMap\n\nConstruct a (lazy) representation of the Kronecker product A⊗B. One of the two factors can be an AbstractMatrix, which is then promoted to a LinearMap automatically.\n\nTo avoid fallback to the generic Base.kron in the multi-map case, there must be a LinearMap object among the first 8 arguments in usage like kron(A, B, Cs...).\n\nFor convenience, one can also use A ⊗ B or ⊗(A, B, Cs...) (typed as \\otimes+TAB) to construct the KroneckerMap, even when all arguments are of AbstractMatrix type.\n\nIf A, B, C and D are linear maps of such size that one can form the matrix products A*C and B*D, then the mixed-product property (A⊗B)*(C⊗D) = (A*C)⊗(B*D) holds. Upon vector multiplication, this rule is checked for applicability.\n\nExamples\n\njulia> J = LinearMap(I, 2) # 2×2 identity map\n2×2 LinearMaps.UniformScalingMap{Bool} with scaling factor: true\n\njulia> E = spdiagm(-1 => trues(1)); D = E + E' - 2I;\n\njulia> Δ = kron(D, J) + kron(J, D); # discrete 2D-Laplace operator\n\njulia> Matrix(Δ)\n4×4 Array{Int64,2}:\n -4   1   1   0\n  1  -4   0   1\n  1   0  -4   1\n  0   1   1  -4\n\n\n\n\n\n","category":"method"},{"location":"types/#LinearMaps.:⊗","page":"Types and methods","title":"LinearMaps.:⊗","text":"⊗(k::Integer)\n\nConstruct a lazy representation of the k-th Kronecker power A^⊗(k) = A ⊗ A ⊗ ... ⊗ A, where A can be an AbstractMatrix or a LinearMap.\n\n\n\n\n\n","category":"function"},{"location":"types/#LinearMaps.kronsum","page":"Types and methods","title":"LinearMaps.kronsum","text":"kronsum(A, B)::KroneckerSumMap\nkronsum(A, B, Cs...)::KroneckerSumMap\n\nConstruct a (lazy) representation of the Kronecker sum A⊕B = A ⊗ Ib + Ia ⊗ B of two square linear maps of type LinearMap or AbstractMatrix. Here, Ia and Ib are identity operators of the size of A and B, respectively. Arguments of type AbstractMatrix are automatically promoted to LinearMap.\n\nFor convenience, one can also use A ⊕ B or ⊕(A, B, Cs...) (typed as \\oplus+TAB) to construct the KroneckerSumMap.\n\nExamples\n\njulia> J = LinearMap(I, 2) # 2×2 identity map\n2×2 LinearMaps.UniformScalingMap{Bool} with scaling factor: true\n\njulia> E = spdiagm(-1 => trues(1)); D = LinearMap(E + E' - 2I);\n\njulia> Δ₁ = kron(D, J) + kron(J, D); # discrete 2D-Laplace operator, Kronecker sum\n\njulia> Δ₂ = kronsum(D, D);\n\njulia> Δ₃ = D^⊕(2);\n\njulia> Matrix(Δ₁) == Matrix(Δ₂) == Matrix(Δ₃)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"types/#LinearMaps.:⊕","page":"Types and methods","title":"LinearMaps.:⊕","text":"⊕(k::Integer)\n\nConstruct a lazy representation of the k-th Kronecker sum power A^⊕(k) = A ⊕ A ⊕ ... ⊕ A, where A can be a square AbstractMatrix or a LinearMap.\n\n\n\n\n\n","category":"function"},{"location":"types/#BlockMap-and-BlockDiagonalMap","page":"Types and methods","title":"BlockMap and BlockDiagonalMap","text":"","category":"section"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"Types for representing block (diagonal) maps lazily.","category":"page"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"Base.hcat\nBase.vcat\nBase.hvcat\nBase.cat\nSparseArrays.blockdiag","category":"page"},{"location":"types/#Base.hcat","page":"Types and methods","title":"Base.hcat","text":"hcat(As::Union{LinearMap,UniformScaling,AbstractVecOrMat}...)::BlockMap\n\nConstruct a (lazy) representation of the horizontal concatenation of the arguments. All arguments are promoted to LinearMaps automatically.\n\nExamples\n\njulia> CS = LinearMap{Int}(cumsum, 3)::LinearMaps.FunctionMap;\n\njulia> L = [CS LinearMap(ones(Int, 3, 3))]::LinearMaps.BlockMap;\n\njulia> L * ones(Int, 6)\n3-element Array{Int64,1}:\n 4\n 5\n 6\n\n\n\n\n\n","category":"function"},{"location":"types/#Base.vcat","page":"Types and methods","title":"Base.vcat","text":"vcat(As::Union{LinearMap,UniformScaling,AbstractVecOrMat}...)::BlockMap\n\nConstruct a (lazy) representation of the vertical concatenation of the arguments. All arguments are promoted to LinearMaps automatically.\n\nExamples\n\njulia> CS = LinearMap{Int}(cumsum, 3)::LinearMaps.FunctionMap;\n\njulia> L = [CS; LinearMap(ones(Int, 3, 3))]::LinearMaps.BlockMap;\n\njulia> L * ones(Int, 3)\n6-element Array{Int64,1}:\n 1\n 2\n 3\n 3\n 3\n 3\n\n\n\n\n\n","category":"function"},{"location":"types/#Base.hvcat","page":"Types and methods","title":"Base.hvcat","text":"hvcat(rows::Tuple{Vararg{Int}}, As::Union{LinearMap,UniformScaling,AbstractVecOrMat}...)::BlockMap\n\nConstruct a (lazy) representation of the horizontal-vertical concatenation of the arguments. The first argument specifies the number of arguments to concatenate in each block row. All arguments are promoted to LinearMaps automatically.\n\nExamples\n\njulia> CS = LinearMap{Int}(cumsum, 3)::LinearMaps.FunctionMap;\n\njulia> L = [CS CS; CS CS]::LinearMaps.BlockMap;\n\njulia> L.rows\n(2, 2)\n\njulia> L * ones(Int, 6)\n6-element Array{Int64,1}:\n 2\n 4\n 6\n 2\n 4\n 6\n\n\n\n\n\n","category":"function"},{"location":"types/#Base.cat","page":"Types and methods","title":"Base.cat","text":"cat(As::Union{LinearMap,AbstractVecOrMat}...; dims=(1,2))::BlockDiagonalMap\n\nConstruct a (lazy) representation of the diagonal concatenation of the arguments. To avoid fallback to the generic Base.cat, there must be a LinearMap object among the first 8 arguments.\n\n\n\n\n\n","category":"function"},{"location":"types/#SparseArrays.blockdiag","page":"Types and methods","title":"SparseArrays.blockdiag","text":"blockdiag(As::Union{LinearMap,AbstractVecOrMat}...)::BlockDiagonalMap\n\nConstruct a (lazy) representation of the diagonal concatenation of the arguments. To avoid fallback to the generic SparseArrays.blockdiag, there must be a LinearMap object among the first 8 arguments.\n\n\n\n\n\n","category":"function"},{"location":"types/#FillMap","page":"Types and methods","title":"FillMap","text":"","category":"section"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"Type for lazily representing constantly filled matrices.","category":"page"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"LinearMaps.FillMap","category":"page"},{"location":"types/#LinearMaps.FillMap","page":"Types and methods","title":"LinearMaps.FillMap","text":"FillMap(λ, (m, n))::FillMap\nFillMap(λ, m, n)::FillMap\n\nConstruct a (lazy) representation of an operator whose matrix representation would be an m×n-matrix filled constantly with the value λ.\n\n\n\n\n\n","category":"type"},{"location":"types/#Methods","page":"Types and methods","title":"Methods","text":"","category":"section"},{"location":"types/#Multiplication-methods","page":"Types and methods","title":"Multiplication methods","text":"","category":"section"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"Base.:*(::LinearMap,::AbstractVector)\nBase.:*(::LinearMap,::AbstractMatrix)\nBase.:*(::AbstractMatrix,::LinearMap)\nLinearAlgebra.mul!(::AbstractVecOrMat,::LinearMap,::AbstractVector)\nLinearAlgebra.mul!(::AbstractVecOrMat,::LinearMap,::AbstractVector,::Number,::Number)\nLinearAlgebra.mul!(::AbstractMatrix,::AbstractMatrix,::LinearMap)\n*(::LinearAlgebra.AdjointAbsVec,::LinearMap)\n*(::LinearAlgebra.TransposeAbsVec,::LinearMap)","category":"page"},{"location":"types/#Base.:*-Tuple{LinearMap,AbstractArray{T,1} where T}","page":"Types and methods","title":"Base.:*","text":"*(A::LinearMap, x::AbstractVector)::AbstractVector\n\nCompute the action of the linear map A on the vector x.\n\ncompat: Julia 1.3\nIn Julia versions v1.3 and above, objects L of any subtype of LinearMap are callable in the sense that L(x) = L*x for x::AbstractVector.\n\nExamples\n\njulia> A=LinearMap([1.0 2.0; 3.0 4.0]); x=[1.0, 1.0];\n\njulia> A*x\n2-element Array{Float64,1}:\n 3.0\n 7.0\n\njulia> A(x)\n2-element Array{Float64,1}:\n 3.0\n 7.0\n\n\n\n\n\n","category":"method"},{"location":"types/#Base.:*-Tuple{LinearMap,AbstractArray{T,2} where T}","page":"Types and methods","title":"Base.:*","text":"*(A::LinearMap, X::AbstractMatrix)::CompositeMap\n\nReturn the CompositeMap A*LinearMap(X), interpreting the matrix X as a linear operator, rather than a collection of column vectors. To compute the action of A on each column of X, call Matrix(A*X) or use the in-place multiplication mul!(Y, A, X[, α, β]) with an appropriately sized, preallocated matrix Y.\n\nExamples\n\njulia> A=LinearMap([1.0 2.0; 3.0 4.0]); X=[1.0 1.0; 1.0 1.0];\n\njulia> A*X isa LinearMaps.CompositeMap\ntrue\n\n\n\n\n\n","category":"method"},{"location":"types/#Base.:*-Tuple{AbstractArray{T,2} where T,LinearMap}","page":"Types and methods","title":"Base.:*","text":"*(X::AbstractMatrix, A::LinearMap)::CompositeMap\n\nReturn the CompositeMap LinearMap(X)*A, interpreting the matrix X as a linear operator. To compute the right-action of A on each row of X, call Matrix(X*A) or mul!(Y, X, A) for the in-place version.\n\nExamples\n\njulia> X=[1.0 1.0; 1.0 1.0]; A=LinearMap([1.0 2.0; 3.0 4.0]);\n\njulia> X*A isa LinearMaps.CompositeMap\ntrue\n\n\n\n\n\n","category":"method"},{"location":"types/#LinearAlgebra.mul!-Tuple{Union{AbstractArray{T,1}, AbstractArray{T,2}} where T,LinearMap,AbstractArray{T,1} where T}","page":"Types and methods","title":"LinearAlgebra.mul!","text":"mul!(Y::AbstractVecOrMat, A::LinearMap, B::AbstractVector) -> Y\nmul!(Y::AbstractMatrix, A::LinearMap, B::AbstractMatrix) -> Y\n\nCalculates the action of the linear map A on the vector or matrix B and stores the result in Y, overwriting the existing value of Y. Note that Y must not be aliased with either A or B.\n\nExamples\n\njulia> A=LinearMap([1.0 2.0; 3.0 4.0]); B=[1.0, 1.0]; Y = similar(B); mul!(Y, A, B);\n\njulia> Y\n2-element Array{Float64,1}:\n 3.0\n 7.0\n\njulia> A=LinearMap([1.0 2.0; 3.0 4.0]); B=[1.0 1.0; 1.0 1.0]; Y = similar(B); mul!(Y, A, B);\n\njulia> Y\n2×2 Array{Float64,2}:\n 3.0  3.0\n 7.0  7.0\n\n\n\n\n\n","category":"method"},{"location":"types/#LinearAlgebra.mul!-Tuple{Union{AbstractArray{T,1}, AbstractArray{T,2}} where T,LinearMap,AbstractArray{T,1} where T,Number,Number}","page":"Types and methods","title":"LinearAlgebra.mul!","text":"mul!(C::AbstractVecOrMat, A::LinearMap, B::AbstractVector, α, β) -> C\nmul!(C::AbstractMatrix, A::LinearMap, B::AbstractMatrix, α, β) -> C\n\nCombined inplace multiply-add A B α + C β. The result is stored in C by overwriting it. Note that C must not be aliased with either A or B.\n\nExamples\n\njulia> A=LinearMap([1.0 2.0; 3.0 4.0]); B=[1.0, 1.0]; C=[1.0, 3.0];\n\njulia> mul!(C, A, B, 100.0, 10.0) === C\ntrue\n\njulia> C\n2-element Array{Float64,1}:\n 310.0\n 730.0\n\njulia> A=LinearMap([1.0 2.0; 3.0 4.0]); B=[1.0 1.0; 1.0 1.0]; C=[1.0 2.0; 3.0 4.0];\n\njulia> mul!(C, A, B, 100.0, 10.0) === C\ntrue\n\njulia> C\n2×2 Array{Float64,2}:\n 310.0  320.0\n 730.0  740.0\n\n\n\n\n\n","category":"method"},{"location":"types/#LinearAlgebra.mul!-Tuple{AbstractArray{T,2} where T,AbstractArray{T,2} where T,LinearMap}","page":"Types and methods","title":"LinearAlgebra.mul!","text":"mul!(C::AbstractMatrix, A::AbstractMatrix, B::LinearMap) -> C\n\nCalculates the matrix representation of A*B and stores the result in C, overwriting the existing value of C. Note that C must not be aliased with either A or B. The computation C = A*B is performed via C' = B'A'.\n\nExamples\n\njulia> A=[1.0 1.0; 1.0 1.0]; B=LinearMap([1.0 2.0; 3.0 4.0]); C = similar(A); mul!(C, A, B);\n\njulia> C\n2×2 Array{Float64,2}:\n 4.0  6.0\n 4.0  6.0\n\n\n\n\n\n","category":"method"},{"location":"types/#Base.:*-Tuple{Adjoint{T,var\"#s828\"} where var\"#s828\"<:(AbstractArray{T,1} where T) where T,LinearMap}","page":"Types and methods","title":"Base.:*","text":"*(x::LinearAlgebra.AdjointAbsVec, A::LinearMap)::AdjointAbsVec\n\nCompute the right-action of the linear map A on the adjoint vector x and return an adjoint vector.\n\nExamples\n\njulia> A=LinearMap([1.0 2.0; 3.0 4.0]); x=[1.0, 1.0]; x'A\n1×2 Adjoint{Float64,Array{Float64,1}}:\n 4.0  6.0\n\n\n\n\n\n","category":"method"},{"location":"types/#Base.:*-Tuple{Transpose{T,var\"#s828\"} where var\"#s828\"<:(AbstractArray{T,1} where T) where T,LinearMap}","page":"Types and methods","title":"Base.:*","text":"*(x::LinearAlgebra.TransposeAbsVec, A::LinearMap)::TransposeAbsVec\n\nCompute the right-action of the linear map A on the transpose vector x and return a transpose vector.\n\nExamples\n\njulia> A=LinearMap([1.0 2.0; 3.0 4.0]); x=[1.0, 1.0]; transpose(x)*A\n1×2 Transpose{Float64,Array{Float64,1}}:\n 4.0  6.0\n\n\n\n\n\n","category":"method"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"Applying the adjoint or transpose of A (if defined) to x works exactly as in the usual matrix case: transpose(A) * x and mul!(y, A', x), for instance.","category":"page"},{"location":"types/#Conversion-methods","page":"Types and methods","title":"Conversion methods","text":"","category":"section"},{"location":"types/","page":"Types and methods","title":"Types and methods","text":"Array, Matrix and associated convert methods\nCreate a dense matrix representation of the LinearMap object, by multiplying it with the successive basis vectors. This is mostly for testing purposes or if you want to have the explicit matrix representation of a linear map for which you only have a function definition (e.g. to be able to use its transpose or adjoint). This way, one may conveniently make A act on the columns of a matrix X, instead of interpreting A * X as a composed linear map: Matrix(A * X). For generic code, that is supposed to handle both A::AbstractMatrix and A::LinearMap, it is recommended to use convert(Matrix, A*X).\nconvert(Abstract[Matrix/Array], A::LinearMap)\nCreate an AbstractMatrix representation of the LinearMap. This falls back to Matrix(A), but avoids explicit construction in case the LinearMap object is matrix-based.\nSparseArrays.sparse(A::LinearMap) and convert(SparseMatrixCSC, A::LinearMap)\nCreate a sparse matrix representation of the LinearMap object, by multiplying it with the successive basis vectors. This is mostly for testing purposes or if you want to have the explicit sparse matrix representation of a linear map for which you only have a function definition (e.g. to be able to use its transpose or adjoint).","category":"page"}]
}
