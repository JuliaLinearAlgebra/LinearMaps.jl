<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Version history · LinearMaps.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">LinearMaps.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Version history</a><ul class="internal"><li><a class="tocitem" href="#What&#39;s-new-in-v3.10"><span>What&#39;s new in v3.10</span></a></li><li><a class="tocitem" href="#What&#39;s-new-in-v3.9"><span>What&#39;s new in v3.9</span></a></li><li><a class="tocitem" href="#What&#39;s-new-in-v3.8"><span>What&#39;s new in v3.8</span></a></li><li><a class="tocitem" href="#What&#39;s-new-in-v3.7"><span>What&#39;s new in v3.7</span></a></li><li><a class="tocitem" href="#What&#39;s-new-in-v3.6"><span>What&#39;s new in v3.6</span></a></li><li><a class="tocitem" href="#What&#39;s-new-in-v3.5"><span>What&#39;s new in v3.5</span></a></li><li><a class="tocitem" href="#What&#39;s-new-in-v3.4"><span>What&#39;s new in v3.4</span></a></li><li><a class="tocitem" href="#What&#39;s-new-in-v3.3"><span>What&#39;s new in v3.3</span></a></li><li><a class="tocitem" href="#What&#39;s-new-in-v3.2"><span>What&#39;s new in v3.2</span></a></li><li><a class="tocitem" href="#What&#39;s-new-in-v3.1"><span>What&#39;s new in v3.1</span></a></li><li><a class="tocitem" href="#What&#39;s-new-in-v3.0"><span>What&#39;s new in v3.0</span></a></li><li><a class="tocitem" href="#What&#39;s-new-in-v2.7"><span>What&#39;s new in v2.7</span></a></li><li><a class="tocitem" href="#What&#39;s-new-in-v2.6"><span>What&#39;s new in v2.6</span></a></li><li><a class="tocitem" href="#What&#39;s-new-in-v2.5"><span>What&#39;s new in v2.5</span></a></li><li><a class="tocitem" href="#What&#39;s-new-in-v2.4"><span>What&#39;s new in v2.4</span></a></li><li><a class="tocitem" href="#What&#39;s-new-in-v2.3"><span>What&#39;s new in v2.3</span></a></li><li><a class="tocitem" href="#What&#39;s-new-in-v2.2"><span>What&#39;s new in v2.2</span></a></li><li><a class="tocitem" href="#What&#39;s-new-in-v2.1"><span>What&#39;s new in v2.1</span></a></li></ul></li><li><a class="tocitem" href="../types/">Types and methods</a></li><li><a class="tocitem" href="../generated/custom/">Custom maps</a></li><li><a class="tocitem" href="../related/">Related packages</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Version history</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Version history</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaLinearAlgebra/LinearMaps.jl/blob/master/docs/src/history.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Version-history"><a class="docs-heading-anchor" href="#Version-history">Version history</a><a id="Version-history-1"></a><a class="docs-heading-anchor-permalink" href="#Version-history" title="Permalink"></a></h1><h2 id="What&#39;s-new-in-v3.10"><a class="docs-heading-anchor" href="#What&#39;s-new-in-v3.10">What&#39;s new in v3.10</a><a id="What&#39;s-new-in-v3.10-1"></a><a class="docs-heading-anchor-permalink" href="#What&#39;s-new-in-v3.10" title="Permalink"></a></h2><ul><li>A new <code>MulStyle</code> trait called <code>TwoArg</code> has been added. It should be used for <code>LinearMap</code>s that do not admit a mutating multiplication à la (3-arg or 5-arg) <code>mul!</code>, but only out-of-place multiplication à la <code>A * x</code>. Products (aka <code>CompositeMap</code>s) and sums (aka <code>LinearCombination</code>s) of <code>TwoArg</code>-<code>LinearMap</code>s now have memory-optimized multiplication kernels. For instance, <code>A*B*C*x</code> for three <code>TwoArg</code>-<code>LinearMap</code>s <code>A</code>, <code>B</code> and <code>C</code> now allocates only <code>y = C*x</code>, <code>z = B*y</code> and the result of <code>A*z</code>.</li><li>The construction of function-based <code>LinearMap</code>s, typed <code>FunctionMap</code>, has been rearranged. Additionally to the convenience constructor <code>LinearMap{T=Float64}(f, [fc,] M, N=M; kwargs...)</code>, the newly exported constructor <code>FunctionMap{T,iip}(f, [fc], M, N; kwargs...)</code> is readily available. Here, <code>iip</code> is either <code>true</code> or <code>false</code>, and encodes whether <code>f</code> (and <code>fc</code> if present) are mutating functions. In the convenience constructor, this is determined via the <code>Bool</code> keyword argument <code>ismutating</code> and may not be fully inferred.</li></ul><h2 id="What&#39;s-new-in-v3.9"><a class="docs-heading-anchor" href="#What&#39;s-new-in-v3.9">What&#39;s new in v3.9</a><a id="What&#39;s-new-in-v3.9-1"></a><a class="docs-heading-anchor-permalink" href="#What&#39;s-new-in-v3.9" title="Permalink"></a></h2><ul><li>The application of <code>LinearMap</code>s to vectors operation, i.e., <code>(A,x) -&gt; A*x = A(x)</code>, is now differentiable w.r.t. to the input <code>x</code> for integration with machine learning frameworks such as <a href="https://fluxml.ai/Flux.jl/stable/"><code>Flux.jl</code></a>. The reverse differentiation rule makes <code>A::LinearMap</code> usable as a static, i.e., non-trainable, layer in a network, and requires the adjoint <code>A&#39;</code> of <code>A</code> to be defined.</li><li>New map types called <code>KhatriRaoMap</code> and <code>FaceSplittingMap</code> are introduced. These correspond to lazy representations of the <a href="https://en.wikipedia.org/wiki/Khatri%E2%80%93Rao_product#Column-wise_Kronecker_product">column-wise Kronecker product</a> and the <a href="https://en.wikipedia.org/wiki/Khatri%E2%80%93Rao_product#Face-splitting_product">row-wise Kronecker product</a> (or &quot;transposed Khatri-Rao product&quot;), respectively. They can be constructed from two matrices <code>A</code> and <code>B</code> via <code>khatrirao(A, B)</code> and <code>facesplitting(A, B)</code>, respectively. The first is particularly efficient as it makes use of the vec-trick for Kronecker products and computes <code>y = khatrirao(A, B) * x</code> for a vector <code>x</code> as <code>y = vec(B * Diagonal(x) * transpose(A))</code>. As such, the Khatri-Rao product can actually be built for general <code>LinearMap</code>s, including function-based types. Even for moderate sizes of 5 or more columns, this map-vector product is faster than first creating the explicit Khatri-Rao product in memory and then multiplying with the vector; not to mention the memory savings. Unfortunately, similar efficiency cannot be achieved for the face-splitting product.</li></ul><h2 id="What&#39;s-new-in-v3.8"><a class="docs-heading-anchor" href="#What&#39;s-new-in-v3.8">What&#39;s new in v3.8</a><a id="What&#39;s-new-in-v3.8-1"></a><a class="docs-heading-anchor-permalink" href="#What&#39;s-new-in-v3.8" title="Permalink"></a></h2><ul><li>A new map called <a href="../types/#LinearMaps.InverseMap"><code>InverseMap</code></a> is introduced. Letting an <code>InverseMap</code> act on a vector is equivalent to solving the linear system, i.e. <code>InverseMap(A) * b</code> is the same as <code>A \ b</code>. The default solver is <code>ldiv!</code>, but can be specified with the <code>solver</code> keyword argument to the constructor (see the docstring for details). Note that <code>A</code> must be compatible with the solver: <code>A</code> can, for example, be a factorization, or another <code>LinearMap</code> in combination with an iterative solver.</li><li>New constructors for lazy representations of Kronecker products (<a href="../types/#LinearMaps.squarekron"><code>squarekron</code></a>) and sums (<a href="../types/#LinearMaps.sumkronsum"><code>sumkronsum</code></a>) for <em>square</em> factors and summands, respectively, are introduced. They target cases with 3 or more factors/summands, and benchmarking intended use cases for comparison with <code>KroneckerMap</code> (constructed via <a href="../types/#Base.kron-Tuple{LinearMap, LinearMap}"><code>Base.kron</code></a>) and <code>KroneckerSumMap</code> (constructed via <a href="../types/#LinearMaps.kronsum"><code>kronsum</code></a>) is recommended.</li></ul><h2 id="What&#39;s-new-in-v3.7"><a class="docs-heading-anchor" href="#What&#39;s-new-in-v3.7">What&#39;s new in v3.7</a><a id="What&#39;s-new-in-v3.7-1"></a><a class="docs-heading-anchor-permalink" href="#What&#39;s-new-in-v3.7" title="Permalink"></a></h2><ul><li><p><code>mul!(M::AbstractMatrix, A::LinearMap, s::Number, a, b)</code> methods are provided, mimicking similar methods in <code>Base.LinearAlgebra</code>. This version allows for the memory efficient implementation of in-place addition and conversion of a <code>LinearMap</code> to <code>Matrix</code>. Efficient specialisations for <code>WrappedMap</code>, <code>ScaledMap</code>, and <code>LinearCombination</code> are provided. If users supply the corresponding <code>_unsafe_mul!</code> method for their custom maps, conversion, construction, and inplace addition will benefit from this supplied efficient implementation. If no specialisation is supplied, a generic fallback is used that is based on feeding the canonical basis of unit vectors to the linear map.</p></li><li><p>A new map type called <code>EmbeddedMap</code> is introduced. It is a wrapper of a &quot;small&quot; <code>LinearMap</code> (or a suitably converted <code>AbstractVecOrMat</code>) embedded into a &quot;larger&quot; zero map. Hence, the &quot;small&quot; map acts only on a subset of the coordinates and maps to another subset of the coordinates of the &quot;large&quot; map. The large map <code>L</code> can therefore be imagined as the composition of a sampling/projection map <code>P</code>, of the small map <code>A</code>, and of an embedding map <code>E</code>: <code>L = E ⋅ A ⋅ P</code>. It is implemented, however, by acting on a view of the vector <code>x</code> and storing the result into a view of the result vector <code>y</code>. Such maps can be constructed by the new methods:</p><ul><li><code>LinearMap(A::MapOrVecOrMat, dims::Dims{2}, index::NTuple{2, AbstractVector{Int}})</code>, where <code>dims</code> is the dimensions of the &quot;large&quot; map and index is a tuple of the <code>x</code>- and <code>y</code>-indices that interact with <code>A</code>, respectively;</li><li><code>LinearMap(A::MapOrVecOrMat, dims::Dims{2}; offset::Dims{2})</code>, where the keyword argument <code>offset</code> determines the dimension of a virtual upper-left zero block, to which <code>A</code> gets (virtually) diagonally appended.</li></ul></li><li><p>An often requested new feature has been added: slicing (i.e., non-scalar indexing) any <code>LinearMap</code> object via <code>Base.getindex</code> overloads. Note, however, that only rather efficient complete slicing operations are implemented: <code>A[:,j]</code>, <code>A[:,J]</code>, and <code>A[:,:]</code>, where <code>j::Integer</code> and <code>J</code> is either of type <code>AbstractVector{&lt;:Integer&gt;}</code> or an <code>AbstractVector{Bool}</code> of appropriate length (&quot;logical slicing&quot;). Partial slicing operations such as <code>A[I,j]</code> and <code>A[I,J]</code> where <code>I</code> is as <code>J</code> above are disallowed.</p><p>Scalar indexing <code>A[i::Integer,j::Integer]</code> as well as other indexing operations that fall back on scalar indexing such as logical indexing by some <code>AbstractMatrix{Bool}</code>, or indexing by vectors of (linear or Cartesian) indices are not supported; as an exception, <code>getindex</code> calls on wrapped <code>AbstractVecOrMat</code>s is forwarded to corresponding <code>getindex</code> methods from <code>Base</code> and therefore allow any type of usual indexing/slicing. If scalar indexing is really required, consider using <code>A[:,j][i]</code> which is as efficient as a reasonable generic implementation for <code>LinearMap</code>s can be.</p><p>Furthermore, (predominantly) horizontal slicing operations require the adjoint operation of the <code>LinearMap</code> type to be defined, or will fail otherwise. Important note: <code>LinearMap</code> objects are meant to model objects that act on vectors efficiently, and are in general <em>not</em> backed up by storage-like types like <code>Array</code>s. Therefore, slicing of <code>LinearMap</code>s is potentially slow, and it may require the (repeated) allocation of standard unit vectors. As a consequence, generic algorithms relying heavily on indexing and/or slicing are likely to run much slower than expected for <code>AbstractArray</code>s. To avoid repeated indexing operations which may involve redundant computations, it is strongly recommended to consider <code>convert</code>ing <code>LinearMap</code>-typed objects to <code>Matrix</code> or <code>SparseMatrixCSC</code> first, if memory permits.</p></li></ul><h2 id="What&#39;s-new-in-v3.6"><a class="docs-heading-anchor" href="#What&#39;s-new-in-v3.6">What&#39;s new in v3.6</a><a id="What&#39;s-new-in-v3.6-1"></a><a class="docs-heading-anchor-permalink" href="#What&#39;s-new-in-v3.6" title="Permalink"></a></h2><ul><li>Support for Julia versions below v1.6 has been dropped.</li><li><code>Block[Diagonal]Map</code>, <code>CompositeMap</code>, <code>KroneckerMap</code> and <code>LinearCombination</code> type objects can now be backed by a <code>Vector</code> of <code>LinearMap</code>-type elements. This can be beneficial in cases where these higher-order <code>LinearMap</code>s are constructed from many maps where a tuple backend may get inefficient or impose hard work for the compiler at construction. The default behavior, however, does not change, and construction of vector-based <code>LinearMap</code>s requires usage of the unexported constructors (&quot;expert usage&quot;), except for constructions like <code>sum([A, B, C])</code> or <code>prod([A, B, C])</code> (<code>== C*B*A</code>), where <code>A</code>, <code>B</code> and <code>C</code> are of some <code>LinearMap</code> type.</li></ul><h2 id="What&#39;s-new-in-v3.5"><a class="docs-heading-anchor" href="#What&#39;s-new-in-v3.5">What&#39;s new in v3.5</a><a id="What&#39;s-new-in-v3.5-1"></a><a class="docs-heading-anchor-permalink" href="#What&#39;s-new-in-v3.5" title="Permalink"></a></h2><ul><li><code>WrappedMap</code>, <code>ScaledMap</code>, <code>LinearCombination</code>, <code>AdjointMap</code>, <code>TransposeMap</code> and <code>CompositeMap</code>, instead of using the default <code>axes(A) = map(oneto, size(A))</code>, now forward calls to <code>axes</code> to the underlying wrapped linear map. This allows allocating operations such as <code>*</code> to determine the appropriate storage and axes type of their outputs. For example, linear maps that wrap <code>BlockArrays</code> will, upon multiplicative action, produce a <code>BlockArrays.PseudoBlockVector</code> with block structure inherited from the operator&#39;s <em>output</em> axes <code>axes(A,1)</code>.</li></ul><h2 id="What&#39;s-new-in-v3.4"><a class="docs-heading-anchor" href="#What&#39;s-new-in-v3.4">What&#39;s new in v3.4</a><a id="What&#39;s-new-in-v3.4-1"></a><a class="docs-heading-anchor-permalink" href="#What&#39;s-new-in-v3.4" title="Permalink"></a></h2><ul><li>In <code>WrappedMap</code> constructors, as implicitly called in addition and mutliplication of <code>LinearMap</code>s and <code>AbstractMatrix</code> objects, (conjugate) symmetry and positive definiteness are only determined for matrix types for which these checks are expected to be very cheap or even known at compile time based on the concrete type. The default for <code>LinearMap</code> subtypes is to call, for instance, <code>issymmetric</code>, because symmetry properties are either stored or easily obtained from constituting maps. For custom matrix types, define corresponding methods <code>LinearMaps._issymmetric</code>, <code>LinearMaps._ishermitian</code> and <code>LinearMaps._isposdef</code> to hook into the property checking mechanism.</li></ul><h2 id="What&#39;s-new-in-v3.3"><a class="docs-heading-anchor" href="#What&#39;s-new-in-v3.3">What&#39;s new in v3.3</a><a id="What&#39;s-new-in-v3.3-1"></a><a class="docs-heading-anchor-permalink" href="#What&#39;s-new-in-v3.3" title="Permalink"></a></h2><ul><li><code>AbstractVector</code>s can now be wrapped by a <code>LinearMap</code> just like <code>AbstractMatrix</code><code>typed objects. Upon wrapping, they are not implicitly reshaped to matrices. This feature might be helpful, for instance, in the lazy representation of rank-1 operators</code>kron(LinearMap(u), v&#39;) == ⊗(u, v&#39;) == u ⊗ v&#39;<code>for vectors</code>u<code>and</code>v<code>. The action on vectors,</code>(u⊗v&#39;)<em>x<code>, is implemented optimally via</code>u</em>(v&#39;x)`.</li></ul><h2 id="What&#39;s-new-in-v3.2"><a class="docs-heading-anchor" href="#What&#39;s-new-in-v3.2">What&#39;s new in v3.2</a><a id="What&#39;s-new-in-v3.2-1"></a><a class="docs-heading-anchor-permalink" href="#What&#39;s-new-in-v3.2" title="Permalink"></a></h2><ul><li>In-place left-multiplication <code>mul!(Y, X, A::LinearMap)</code> is now allowed for <code>X::AbstractMatrix</code> and implemented via the adjoint equation <code>Y&#39; = A&#39;X&#39;</code>.</li></ul><h2 id="What&#39;s-new-in-v3.1"><a class="docs-heading-anchor" href="#What&#39;s-new-in-v3.1">What&#39;s new in v3.1</a><a id="What&#39;s-new-in-v3.1-1"></a><a class="docs-heading-anchor-permalink" href="#What&#39;s-new-in-v3.1" title="Permalink"></a></h2><ul><li>In Julia v1.3 and above, <code>LinearMap</code>-typed objects are callable on <code>AbstractVector</code>s: For <code>L::LinearMap</code> and <code>x::AbstractVector</code>, <code>L(x) = L*x</code>.</li></ul><h2 id="What&#39;s-new-in-v3.0"><a class="docs-heading-anchor" href="#What&#39;s-new-in-v3.0">What&#39;s new in v3.0</a><a id="What&#39;s-new-in-v3.0-1"></a><a class="docs-heading-anchor-permalink" href="#What&#39;s-new-in-v3.0" title="Permalink"></a></h2><ul><li>BREAKING change: Internally, any dependence on former <code>A*_mul_B!</code> methods is abandonned. For custom <code>LinearMap</code> subtypes, there are now two options:<ol><li>In case your type is invariant under adjoint/transposition (i.e., <code>adjoint(L::MyLinearMap)::MyLinearMap</code> similar to, for instance, <code>LinearCombination</code>s or <code>CompositeMap</code>s), <code>At_mul_B!</code> and <code>Ac_mul_B!</code> do not require any replacement! Rather, multiplication by <code>L&#39;</code> is, in this case, handled by <code>mul!(y, L::MyLinearMap, x[, α, β])</code>.</li><li>Otherwise, you will need to define <code>mul!</code> methods with the signature <code>mul!(y, L::TransposeMap{&lt;:Any,MyLinearMap}, x[, α, β])</code> and <code>mul!(y, L::AdjointMap{&lt;:Any,MyLinearMap}, x[, α, β])</code>.</li></ol></li><li>Left multiplying by a transpose or adjoint vector (e.g., <code>y&#39;*A</code>) produces a transpose or adjoint vector output, rather than a composite <code>LinearMap</code>.</li><li>Block concatenation now handles matrices and vectors directly by internal promotion to <code>LinearMap</code>s. For <code>[h/v/hc]cat</code> it suffices to have a <code>LinearMap</code> object anywhere in the list of arguments. For the block-diagonal concatenation via <code>SparseArrays.blockdiag</code>, a <code>LinearMap</code> object has to appear among the first 8 arguments. This restriction, however, does not apply to block-diagonal concatenation via <code>Base.cat(As...; dims=(1,2))</code>.</li><li>Introduction of more expressive and visually appealing <code>show</code> methods, replacing the fallback to the generic <code>show</code>.</li></ul><h2 id="What&#39;s-new-in-v2.7"><a class="docs-heading-anchor" href="#What&#39;s-new-in-v2.7">What&#39;s new in v2.7</a><a id="What&#39;s-new-in-v2.7-1"></a><a class="docs-heading-anchor-permalink" href="#What&#39;s-new-in-v2.7" title="Permalink"></a></h2><ul><li>Potential reduction of memory allocations in multiplication of <code>LinearCombination</code>s, <code>BlockMap</code>s, and real- or complex-scaled <code>LinearMap</code>s. For the latter, a new internal type <code>ScaledMap</code> has been introduced.</li><li>Multiplication code for <code>CompositeMap</code>s has been refactored to facilitate to provide memory for storage of intermediate results by directly calling helper functions.</li></ul><h2 id="What&#39;s-new-in-v2.6"><a class="docs-heading-anchor" href="#What&#39;s-new-in-v2.6">What&#39;s new in v2.6</a><a id="What&#39;s-new-in-v2.6-1"></a><a class="docs-heading-anchor-permalink" href="#What&#39;s-new-in-v2.6" title="Permalink"></a></h2><ul><li>New feature: &quot;lazy&quot; Kronecker product, Kronecker sums, and powers thereof for <code>LinearMap</code>s. <code>AbstractMatrix</code> objects are promoted to <code>LinearMap</code>s if one of the first 8 Kronecker factors is a <code>LinearMap</code> object.</li><li>Compatibility with the generic multiply-and-add interface (a.k.a. 5-arg <code>mul!</code>) introduced in julia v1.3</li></ul><h2 id="What&#39;s-new-in-v2.5"><a class="docs-heading-anchor" href="#What&#39;s-new-in-v2.5">What&#39;s new in v2.5</a><a id="What&#39;s-new-in-v2.5-1"></a><a class="docs-heading-anchor-permalink" href="#What&#39;s-new-in-v2.5" title="Permalink"></a></h2><ul><li>New feature: concatenation of <code>LinearMap</code>s objects with <code>UniformScaling</code>s, consistent with (h-, v-, and hc-)concatenation of matrices. Note, matrices <code>A</code> must be wrapped as <code>LinearMap(A)</code>, <code>UniformScaling</code>s are promoted to <code>LinearMap</code>s automatically.</li></ul><h2 id="What&#39;s-new-in-v2.4"><a class="docs-heading-anchor" href="#What&#39;s-new-in-v2.4">What&#39;s new in v2.4</a><a id="What&#39;s-new-in-v2.4-1"></a><a class="docs-heading-anchor-permalink" href="#What&#39;s-new-in-v2.4" title="Permalink"></a></h2><ul><li>Support restricted to Julia v1.0+.</li></ul><h2 id="What&#39;s-new-in-v2.3"><a class="docs-heading-anchor" href="#What&#39;s-new-in-v2.3">What&#39;s new in v2.3</a><a id="What&#39;s-new-in-v2.3-1"></a><a class="docs-heading-anchor-permalink" href="#What&#39;s-new-in-v2.3" title="Permalink"></a></h2><ul><li>Fully Julia v0.7/v1.0/v1.1 compatible.</li><li>Full support of noncommutative number types such as quaternions.</li></ul><h2 id="What&#39;s-new-in-v2.2"><a class="docs-heading-anchor" href="#What&#39;s-new-in-v2.2">What&#39;s new in v2.2</a><a id="What&#39;s-new-in-v2.2-1"></a><a class="docs-heading-anchor-permalink" href="#What&#39;s-new-in-v2.2" title="Permalink"></a></h2><ul><li>Fully Julia v0.7/v1.0 compatible.</li><li>A <code>convert(SparseMatrixCSC, A::LinearMap)</code> function, that calls the <code>sparse</code> matrix generating function.</li></ul><h2 id="What&#39;s-new-in-v2.1"><a class="docs-heading-anchor" href="#What&#39;s-new-in-v2.1">What&#39;s new in v2.1</a><a id="What&#39;s-new-in-v2.1-1"></a><a class="docs-heading-anchor-permalink" href="#What&#39;s-new-in-v2.1" title="Permalink"></a></h2><ul><li>Fully Julia v0.7 compatible; dropped compatibility for previous versions of Julia from LinearMaps.jl v2.0.0 on.</li><li>A 5-argument version for <code>mul!(y, A::LinearMap, x, α=1, β=0)</code>, which computes <code>y := α * A * x + β * y</code> and implements the usual 3-argument <code>mul!(y, A, x)</code> for the default <code>α</code> and <code>β</code>.</li><li>Synonymous <code>convert(Matrix, A::LinearMap)</code> and <code>convert(Array, A::LinearMap)</code> functions, that call the <code>Matrix</code> constructor and return the matrix representation of <code>A</code>.</li><li>Multiplication with matrices, interpreted as a block row vector of vectors:<ul><li><code>mul!(Y::AbstractArray, A::LinearMap, X::AbstractArray, α=1, β=0)</code>: applies <code>A</code> to each column of <code>X</code> and stores the result in-place in the corresponding column of <code>Y</code>;</li><li>for the out-of-place multiplication, the approach is to compute <code>convert(Matrix, A * X)</code>; this is equivalent to applying <code>A</code> to each column of <code>X</code>. In generic code which handles both <code>A::AbstractMatrix</code> and <code>A::LinearMap</code>, the additional call to <code>convert</code> is a noop when <code>A</code> is a matrix.</li></ul></li><li>Full compatibility with <a href="https://github.com/JuliaLinearAlgebra/Arpack.jl">Arpack.jl</a>&#39;s <code>eigs</code> and <code>svds</code>; previously only <code>eigs</code> was working. For more, nicely collaborating packages see the <a href="#example">Example</a> section.</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../types/">Types and methods »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 7 June 2023 15:00">Wednesday 7 June 2023</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
